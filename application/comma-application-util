#!/bin/bash

# This file is part of comma, a generic and flexible library
# Copyright (c) 2011 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# this script is designed to be included in another script directly, for example:
# source $( which comma-application-util )

[[ -n "$comma_application_util_include_guard_" ]] && return
readonly comma_application_util_include_guard_=1

source $( which comma-name-value-util ) || { echo "comma-application-util: comma-name-value-util not found" >&2 ; exit 1 ; } # for backward compatibility

# usage: get_children [<pid>] [--recursive]
# output the process ids of all children of a process (space separated); by default, just direct children,
# not descendants
# options:
#   <pid = positive integer>    Target process (only one allowed) (default = current process)
#   --recursive                 Get all descendants, not just immediate children
function get_children()
{
    local is_recursive=0
    local target_pid=$BASHPID   # using $BASHPID instead of $$ handles subshells properly (e.g backgrounded functions)

    while [[ $# -ne 0 ]]; do
        case $1 in
            --recursive) is_recursive=1;;
            -*)          echo "$0: get_children(): unknown option '$1'" >&2; return 1;;
            *)           target_pid=$1;;
        esac
        shift
    done

    if (( is_recursive )); then
        ps -eo ppid:1,pid:1 | gawk '
            { child[$1, ++num_children[$1]] = $2; }
            # idosyncracy of gawk: local function variables must be defined as (unused) function arguments
            function print_children(parent, local_n) \
            {
                for (local_n = 1;local_n <= num_children[parent];local_n++)
                {
                    printf "%s%s", separator, child[parent, local_n];
                    separator = " ";
                    print_children(child[parent, local_n]);
                }
            }
            END { print_children('"$target_pid"'); printf "\n"; }'
    else
        ps -eo ppid:1,pid:1 | grep "^$target_pid " | cut -f2 -d' ' | tr '\n' ' ' | sed 's/ $//g'
        echo   # add final newline
    fi
}
export -f get_children

# usage: stacktrace <any message>
# print the stacktrace, the list of lines and script names that were passed
# through on the way to the currently executed line of the script
# finally prints the supplied arguments, if any
function stacktrace()
{
    local frame=0

    while caller $frame; do
        ((frame++));
    done

    echo "$*"
}
export -f stacktrace

# usage: kill_children [<pid>] [--recursive] [-<"kill" options> ...]
# kill all children of a process
# options:
#   <pid = positive integer>    Process to kill (only one allowed) (default = current process)
#   -<"kill" option ...>        Options to pass to the "kill" command (e.g. -SIGUSR1 or -9)
#   --recursive                 Kills all descendants, not just immediate children
function kill_children()
{
    local recursive_option=
    local kill_options=()
    local target_pid=$BASHPID   # using $BASHPID instead of $$ handles subshells properly (e.g backgrounded functions)

    while [[ $# -ne 0 ]]; do
        case $1 in
            --recursive) recursive_option="--recursive";;
            -*)          kill_options+=( $1 );;
            *)           target_pid=$1;;
        esac
        shift
    done

    local child_pids=$( get_children $recursive_option $target_pid )
    kill ${kill_options[@]} $child_pids 2> /dev/null
}
export -f kill_children

# Trim leading and trailing whitespaces
# Usage:
#    var=$( comma_trim "$var" )
function comma_trim()
{
    (
        shopt -s extglob ; a=$1 ; b=${a%%*( )} ; b=${b##*( )} ; echo "$b"
    )
}
export -f comma_trim

# Run commands in a minimal environment.
#
# Usage:
#
# To run <your-command> with the given arguments in a clean environment with
# the minimal number of variables inherited from the parent environment:
#   comma_env --default your-command arg1 arg2 ...
#
# To list the default variables to be imported and return:
#   comma_env --default-imports
#
# To run <your-command> with the provided arguments in the shell environment that
# inherit the default and the explicitly listed variables from the parent environment:
#   comma_env --import=FOO,BAR,LICENSE,MYENV your-command arg1 arg2 ...
#
# The options of comma_env must be given first. It does not search for them in the
# entire command line, assuming options in other positions belong to <your-command>.
#
# Variables shall be given as a comma-separated list. Both --import=<list> and
# --import <list> forms are supported. If a variable is not set in the parent
# environment, it is not set. Set a variable to an empty string if it shall be present.
# All the default and user-specified variables are exported.
#
# To see the resulting environment without running any commands in it, give '-'
# (a single minus character) as <your-command>.
#
# If you need to call (or use) a bash function, add it to the --import list, such
# as in:
#   function foo(){ ls --reverse; }
#   comma_env --import=foo foo
#
# All the listed functions are "export -f"-ed.
#
# Exit status of comma_env is defined by env (1). See "info coreutils 'env invocation'"
# for details.
function comma_env()
{
    local comma_env_show_help="false"
    (( $# == 0 )) && comma_env_show_help="true"
    [[ "$1" == "--help" ]] && comma_env_show_help="true"
    [[ "$comma_env_show_help" == "true" ]] && {
    cat >&2 <<EOF
Usage:
    comma_env --import=<list,of,variable,names> your-command arg1 arg2
    comma_env --import <list,of,variable,names> your-command arg1 arg2
    comma_env --default your-command arg1 arg1
    comma_env --default-imports
    comma_env --help
EOF
    return $(( $# == 0 ))
    }

    local comma_env_default_list="HOME,HOSTNAME,LANG,LANGUAGE,LD_LIBRARY_PATH,LOGNAME,USER" # PATH handled separately
    [[ "$1" == "--default-imports" ]] && { echo "$comma_env_default_list,PATH" ; return 0 ; }

    local comma_env_variables_list=$comma_env_default_list
    case "$1" in
        --import)    shift ; comma_env_variables_list="$comma_env_default_list,$1" ; shift ;;
        --import=*)  comma_env_variables_list="$comma_env_default_list,${1#*=}" ; shift ;;
        --default)   shift ;;
        *)           echo "comma_env: first argument must be '--import' or '--default', not '$1'" >&2 ; return 1 ;;
    esac

    # remove possible repetitions
    comma_env_variables_list=$( echo "$comma_env_variables_list" | tr ',' '\n' | sort -u )
    comma_env_variables_list=$( echo $comma_env_variables_list )  # convert newlines to spaces

    # work in a subshell to use a custom EXIT trap
    (
        comma_env_temp_file=$( mktemp --dry-run -t comma-env.XXXXXXXX )
        trap "rm -f \"$comma_env_temp_file\"" EXIT
        local comma_env_command_to_execute=""
        [[ "$*" == "-" ]] && { comma_env_command_to_execute="set" ; shift ; }
        local comma_env_variable_name
        for comma_env_variable_name in $comma_env_variables_list ; do
            if type "$comma_env_variable_name" 2>/dev/null | head -n 1 | grep -q "is a function" ; then
                type "$comma_env_variable_name" | tail -n +2 >> "$comma_env_temp_file"
                echo "export -f $comma_env_variable_name" >> "$comma_env_temp_file"
            else
                [[ -v $comma_env_variable_name ]] && echo "export $comma_env_variable_name=\"$( eval echo \$$comma_env_variable_name )\"" >> "$comma_env_temp_file"
            fi
        done
        # handle PATH explicitly
        env -i PATH="$PATH" comma-env-helper "$comma_env_temp_file" $comma_env_command_to_execute $@ # do not quote the second argument to helper
    )
}
export -f comma_env

# This is a signal handler used by comma_execute_and_wait. See that function for detail.
function terminate_comma_execute_and_wait()
{
    trap '' SIGTERM SIGINT SIGHUP SIGPIPE SIGQUIT      # temporarily ignore signals
    local usepg=$1
    local killsign="-"
    [[ "$usepg" == "false" ]] && killsign=""
    local received_signal=$2
    echo "comma_execute_and_wait: interrupted by $received_signal, killsign='$killsign'" >&2
    # kill the command(s) being executed
    local command_to_execute_index
    for command_to_execute_index in ${!commands_to_execute_pgid[@]} ; do
        if [[ -n "${commands_to_execute_pgid[$command_to_execute_index]}" ]] ; then
            kill -s $received_signal -- ${killsign}${commands_to_execute_pgid[$command_to_execute_index]}
            wait ${commands_to_execute_pgid[$command_to_execute_index]}
            commands_to_execute_pgid[$command_to_execute_index]=""
        fi
    done
    eval "$comma_execute_and_wait_saved_traps"  # use old handlers
    unset comma_execute_and_wait_saved_traps
    echo "comma_execute_and_wait: re-raise $received_signal" >&2
    kill -s $received_signal $BASHPID           # relinguish control
}
export -f terminate_comma_execute_and_wait

# Usage:
#   comma_execute_and_wait command[,command2[,command3]] [--signals=signal1,signal2,...] \
#                          [--max-wait=max_wait] [--process|--group] [--any|--all]
#
# The function executes the given command(s) (non-option argument) in a background process(es)
# and waits for its completion (or timeout, see below).
#
# Usually the command is executed in a separate process group. As such, it inherits from
# the original process its environment variables but not the shell variables. In this usage
# mode, the command to be executed must be a self-contained string that can be used "as-is":
# - if it is a bash function, this function shall be 'export -f'-ed
# - if some variables are used within a function / script, those variables shall be exported
# - if it is a function, it shall be prepended with "bash -c"
# - command shall not contain pipes, output redirection and such; wrap pipelines into functions
#   or scripts; pass the output file name into the function / script being executed and redirect
#   inside
# - etc.
#
# Alternatively, the command may be executed as a background process in the same process group.
# If so, it would have all shell variables accessible. However, the command may need to provide
# more elaborate signal handling so that a signal sent to a single process would terminate
# the entire process tree. Use '--process' to run the command without creating a new process
# group ('--group', the default). Do not prepend bash functions with 'bash -c' in this mode.
#
# The '--signals' option specifies signals to wait for. Default is INT,HUP,TERM (signals are
# given as comma-separated list of names). If any of the specified signals arrives, the command
# (process or process group) being executed is killed by the same signal, the signal traps are
# restored to their state prior to the entry into comma_execute_and_wait, and the same signal is
# re-raised (sent to itself), possibly triggering one of the restored traps.
#
# Note that if any of your functions is invoked under bash you may not receive the signal you
# expect (the one you sent earlier to terminate the function being executed). Bash may (likely
# will) intercept the original signal and sent HUP to the process running under it. Thus, your
# code shall be always prepared to handle HUP.
#
# If the custom timeout is provided (in time units and format understood by timeout (1) utility)
# and the command-to-execute takes longer, it is terminated by SIGTERM, traps are restored, and
# the function returns 1. The default timeout is 4294967296 days (about 10 million years),
# effectively infinite. The timeout option is available only in '--group' mode. This option is
# incompatible with '--process' mode.
#
# If multiple commands are given, they are all started in parallel. To avoid system overload,
# the user may write a custom script to invoke comma_execute_and_wait in combination with xargs.
# The unit test in "parallel" directory provides a code template. You shall provide a way to
# distribute signals to all instances to comma_execute_and_wait that are used in this fashion.
#
# The exit code of comma_execute_and_wait equals the exit code of the command-to-execute
# accounting for possible signal handling. If multiple commands are given, the exit code
# by default is zero if all commands succeed, and one if any fails. This can be explicitly
# enforced by '--all' option. If '--any' option is given, however, the exit code is zero
# if at least one command succeeded, and one if all of them fail.
function comma_execute_and_wait()
{
    # store existing traps for restoring on exit
    comma_execute_and_wait_saved_traps=$( trap )

    # defaults
    local signal_list="TERM,INT,HUP"
    local commands_to_execute=()
    # timeout default is very long time, essentially, forever
    local execute_and_wait_timeout="4294967296d"
    local timeout_given="false"

    # process arguments
    local original_args="$@"
    local usepg="true"
    local statusall="true"
    while [[ $# -ne 0 ]]; do
        case $1 in
            --signals=*|--signal-list=*) signal_list=${1#*=};;
            --max-wait=*|--timeout=*)    execute_and_wait_timeout=${1#*=} ; timeout_given="true";;
            --group)                     usepg="true";;
            --process)                   usepg="false";;
            --all)                       statusall="true";;
            --any)                       statusall="false";;
            -*)                          echo "comma_execute_and_wait: unknown option '$1' (called: comma_execute_and_wait $original_args)" >&2; return 1;;
            *)                           commands_to_execute+=( "$1" );;
        esac
        shift
    done
    if [[ "$usepg" == "false" && "$timeout_given" == "true" ]] ; then
        echo "comma_execute_and_wait: conflicting timeout and process options (called: comma_execute_and_wait $original_args)" >&2
        return 1
    fi

    # set up a new signal handler / trap that:
    # - determines the signal being sent so that the same signal can be re-raised
    # - if the command-to-execute is running, kill its process group
    # - restores the traps
    # - re-sends the trapped signal to itself
    local signal_to_handle
    for signal_to_handle in ${signal_list//,/ } ; do
        trap 'terminate_comma_execute_and_wait $usepg $signal_to_handle' $signal_to_handle
    done

    local commands_to_execute_pgid=()
    local commands_to_execute_status=0
    [[ "$statusall" == "false" ]] && commands_to_execute_status=1
    local command_to_execute cmd shellfcn

    for command_to_execute in "${commands_to_execute[@]}" ; do
        # shell functions require special handling due to quote spaces
        command_to_execute=$( comma_trim "$command_to_execute" )
        cmd=$( shopt -s extglob ; cmd=${command_to_execute##bash*( )-c*( )}; echo "$cmd" )
        if [[ "$cmd" != "$command_to_execute" ]] ; then
            shellfcn="true"
            command_to_execute="$cmd"
        fi

        # run the command-to-execute as a background process or as a background job in
        # its own process group and under timeout
        if [[ "$usepg" == "true" ]] ; then
            if [[ "$shellfcn" == "true" ]] ; then
                timeout -k 10 -s TERM $execute_and_wait_timeout bash -c "$command_to_execute" & commands_to_execute_pgid+=( $! )
            else
                timeout -k 10 -s TERM $execute_and_wait_timeout $command_to_execute & commands_to_execute_pgid+=( $! )
            fi
        else
            if [[ "$shellfcn" == "true" ]] ; then
                bash -c "$command_to_execute" & commands_to_execute_pgid+=( $! )
            else
                $command_to_execute & commands_to_execute_pgid+=( $! )
            fi
        fi
    done

    # wait for the completion of the subprocess(es)
    local command_to_execute_status command_to_execute_index
    for command_to_execute_index in ${!commands_to_execute_pgid[@]} ; do
        wait ${commands_to_execute_pgid[$command_to_execute_index]} ; command_to_execute_status=$? ; commands_to_execute_pgid[$command_to_execute_index]=""
        if (( ${#commands_to_execute[@]} == 1 )) ; then
            # use as-is
            commands_to_execute_status=$command_to_execute_status
        else
            # accumulate
            if [[ "$statusall" == "true" ]] ; then
                (( $command_to_execute_status == 0 )) || commands_to_execute_status=1
            else
                (( $command_to_execute_status == 0 )) && commands_to_execute_status=0
            fi
        fi
    done
    # restore traps
    trap - ${signal_list//,/ } ; eval "$comma_execute_and_wait_saved_traps"; unset comma_execute_and_wait_saved_traps
    # return the wait outcome
    return $commands_to_execute_status
}
export -f comma_execute_and_wait

# usage: comma_trap [<"cleanup" command>] [<signal list> ...] [--exit[=]<exit code>] [--kill-children|--no-kill-children|--kill-recursive] (default = --kill-recursive)
# Trap termination signals.
# Order of arguments does not matter; arguments starting with "SIG" are assumed to be signal names.
# If no signals are listed, SIGTERM (the default "kill" signal) and SIGINT (control-C) are implied,
# otherwise all signals must be specified explicitly.
#
# The optional "cleanup" command should perform any necessary cleanup for the script, but should not call "exit"
# (exit is automatic).
# The default exit code is 1; use option --exit to set the code (doesn't work for SIGINT).
# The variable $SIGNAL_NAME may be used in the cleanup command (the name of the signal caught),
# but be sure to use single quotes in this case.
#
# Examples:
#
# comma_trap
# comma_trap --exit 3
# comma_trap 'echo Killed' SIGTERM SIGINT SIGQUIT --kill-children
# comma_trap SIGTERM SIGINT SIGQUIT SIGHUP
# comma_trap SIGINT 'echo Cleaning up; rm -f $tmp_dir'
# comma_trap do_cleanup SIGTERM
#
function comma_trap()
{
    local cleanup_command=""
    local signal_list=()
    local kill_option="--kill-recursive"
    local exit_code=1
    local script_name=""
    local original_args="$*"
    while [[ $# -ne 0 ]]; do
        case $1 in
            SIG*)     signal_list+=( $1 );;
            INT|TERM) echo "comma_trap: signal names must start with 'SIG' (found '$1') (called: comma_trap $original_args)" >&2; return 1;;
            --kill-children|--kill-recursive) kill_option=$1;;
            --no-kill-children)               kill_option="";;
            --exit=*)                         exit_code=${1#*=};;
            --exit)                           shift; exit_code=$1;;
            --name=*)                         script_name=${1#*=};;
            -*) echo "comma_trap: unknown option '$1' (called: comma_trap $original_args)" >&2; return 1;;
            *)  if [[ -n "$cleanup_command" || "$1" =~ ^[0-9]+$ ]]; then
                echo "comma_trap: unexpected argument '$1' (called: comma_trap $original_args)" >&2; return 1
                else cleanup_command=$1; fi;;
        esac
        shift
    done

    if echo $cleanup_command | grep -q "\<exit\>"; then
        echo "comma_trap: cleanup command cannot contain 'exit' (called: comma_trap $original_args)" >&2; return 1
    fi

    if [[ ! "$exit_code" =~ ^[0-9]+$ ]]; then
        echo "comma_trap: illegal exit code '$exit_code' (called: comma_trap $original_args)" >&2; return 1
    fi

    local trap_options="$kill_option --exit=$exit_code"
    if [[ -n "$script_name" ]]; then trap_options+=" --name=$script_name"; fi
    if [[ ${#signal_list[@]} == 0 ]]; then signal_list=( "SIGINT" "SIGTERM" ); fi

    local sig
    local sig_option
    for sig in ${signal_list[@]}; do
        if [[ $sig == "SIGINT" ]]; then sig_option="--SIGINT"; else sig_option=""; fi
        trap "SIGNAL_NAME='$sig'; comma_trap_bye_impl '$cleanup_command' $trap_options $sig_option" $sig
    done
}
export -f comma_trap

# Used by comma_trap; do not call this function directly.
# Usage: comma_trap_bye_impl <cleanup command> [<options ...>]
# Options:
#   --name=<caller>     Name of script
#   --exit=<exit code>  Exit code to use (default: 1)
#   --SIGINT            Interrupted by SIGINT (control-C)
#   --kill-children     Kill (direct) children of the current process (default)
#   --kill-recursive    Kill all descendants, not just direct children
function comma_trap_bye_impl()
{
    # ignore signals while handling a signal
    trap '' SIGHUP SIGINT SIGTERM SIGPIPE SIGQUIT
    local cleanup_command=$1
    shift

    local exit_code=1
    local caught_sigint=0
    local kill_option
    local script_name
    while [[ $# -ne 0 ]]; do
        case $1 in
            --kill-children|--kill-recursive)
                      kill_option=$1;;
            --SIGINT) caught_sigint=1;;
            --name=*) script_name=${1#*=};;
            --exit=*) exit_code=${1#*=};;
            -*)       echo "comma_trap_bye_impl(): unknown option '$1'" >&2; return 1;;
            *)        echo "comma_trap_bye_impl(): unexpected argument '$1'" >&2; exit 1;;
        esac
        shift
    done

    local msg
    if [[ -n "$script_name" ]]; then msg="$script_name "; fi
    msg+="(pid $BASHPID): comma_trap caught $SIGNAL_NAME"
    local kill_command

    if [[ "$kill_option" == "--kill-children" ]]; then
        kill_command="kill_children"
        msg+=": killing children"
    elif [[ "$kill_option" == "--kill-recursive" ]]; then
        kill_command="kill_children --recursive"
        msg+=": killing children recursively"
    fi
    if (( caught_sigint )); then msg+="; propagating SIGINT"; fi

    echo $msg >&2
    if [[ -n "$kill_command" ]]; then $kill_command; fi
    if [[ -n "$cleanup_command" ]]; then eval "$cleanup_command"; fi

    if (( caught_sigint )); then trap - SIGINT; kill -SIGINT $BASHPID; fi
    exit $exit_code
}
export -f comma_trap_bye_impl

# usage: my_options=( $( cat name-value-pairs | comma_options_from_name_value [<options>] ) )
#
# options
#     --use-equal-sign: options set as --file=foo.txt; default --file foo.txt
#
# todo: there still may be trouble with option values with spaces inside; check and test it... later...
#
# example (try it)
#      echo -e hello=\"\\\"world\\\"\"\\nverbose=\"true\" | comma_options_from_path_value
function comma_options_from_name_value()
{
    local delimiter='\n'
    if [[ "$1" == "--use-equal-sign" ]] ; then delimiter='=' ; fi
    sed 's/^/--/g' \
        | sed 's/="true"$//g' \
        | sed 's/="false"$//g' \
        | sed 's/="/=/g' \
        | sed 's/"$//g' \
        | sed 's/\\"/"/g' \
        | tr '=' "$delimiter"
}
export -f comma_options_from_name_value

# usage: comma_options_has <what> $@
# example:
#     if (( $( comma_options_has --help $@ ) || $( comma_options_has -h $@ ) )) ; then usage ; fi
function comma_options_has()
{
    for a in ${@:2} ; do if [[ "$1" == "$a" || "$a" =~ ${1}= ]] ; then echo 1 ; exit ; fi ; done
    echo 0
}
export -f comma_options_has

# verify the overall exit status of a pipeline ($? reports only the status of the last step
# in a pipeline); ignore termination by SIGPIPE
#
# rationale for ignoring SIGPIPE: if in a pipeline " A | B " the process "B" may exit before A,
# so that A (pipe writer) has no reader, then A is killed by SIGPIPE and has non-zero exit status
# however, this may be (and likely is) not an error overall, as B has simply finished
# processing and terminated
#
# example
# A | B | C | D
# if ! status_ok ; then echo "failed"; else echo "ok"; fi

# define this value once to avoid calling subprocesses inside status_ok
comma_sigpipe_exit_status_=$( expr 128 \+ $( kill -l SIGPIPE ) )
export comma_sigpipe_exit_status_

function comma_status_ok()
{
    pipestatus_copy_status_ok=("${PIPESTATUS[@]}")  # make a safe copy
    local outcome_status_ok=""
    for outcome_status_ok in "${pipestatus_copy_status_ok[@]}" ; do
        (( outcome_status_ok == 0 || outcome_status_ok == comma_sigpipe_exit_status_ )) || return 1
    done
    return 0
}
export -f comma_status_ok

function wait_for_process_group()
{
    local caller_name=$1
    local process_group_id=$2
    local max_wait_time=$3
    [[ -n "$max_wait_time" ]] || max_wait_time="forever"
    local iter=0
    local leftovers
    while true ; do
        leftovers=$( ps --no-headers -u $USER -o pgid | grep "$process_group_id" )
        [[ -n "$leftovers" ]] && { echo "$caller_name: waited ${iter}s for $process_group_id, keep waiting" >&2; sleep 1; } || { return 0; }
        (( ++iter ))
        if [[ "$max_wait_time" != "forever" ]] ; then
            (( iter > max_wait_time )) && { echo "$caller_name: exceeded $max_wait_time timeout in waiting for $process_group_id" >&2; return 1; }
        fi
    done
}
export -f wait_for_process_group
