#!/bin/bash

source $( which comma-application-util ) || exit 1

export output_dir="output"
rm -rf "$output_dir" || exit 1
mkdir -p "$output_dir" || exit 1

# set up signal handler; run comma-execute and wait; verify that original
# handler has been restored
function test01_trap()
{
    exit 1
}
export -f test01_trap

function test01()
{
    # work in a subprocess to prevent setting traps in the script itself
    (
        trap 'test01_trap' SIGUSR1
        start_traps=$( trap )
        comma_execute_and_wait "comma-nap 5" >/dev/null
        end_traps=$( trap )
        echo "test[1]/traps/start=\"$start_traps\""
        echo "test[1]/traps/end=\"$end_traps\""
        echo "test[1]/traps/SIGUSR1=$( echo "$start_traps" | grep -q SIGUSR1 && echo 1 || echo 0 )"
    )
}
test01 ; echo "test[1]/exit/status=$?"

# kill the process running comma_execute_and_wait; verify that command being
# executed is killed, and that the expected exit status is returned
function test02_trap()
{
    echo "killed by $1"
    exit 11
}
export -f test02_trap

function test02_to_execute()
{
    trap 'test02_trap TERM' SIGTERM
    trap 'test02_trap HUP'  SIGHUP
    trap 'test02_trap PIPE' SIGPIPE
    trap 'test02_trap INT'  SIGINT
    trap 'test02_trap USR1' SIGUSR1
    comma-nap 10 &
    wait $!
}
export -f test02_to_execute

function test02_to_be_killed()
{
    comma_execute_and_wait "bash -c test02_to_execute" > $output_file
}
export -f test02_to_be_killed

function test02()
{
    (
        export output_file="$output_dir/test02.log"
        # will kill the function by timer (which is shorter than expected run-time)
        timeout -k 10 -s TERM 5 bash -c test02_to_be_killed &
        wait $!
    )
}
test02 ; echo "test[2]/exit/status=$?" ; echo "test[2]/output=\""$( cat "$output_dir"/test02.log )"\""

# similar to test02, but use an external script
# note the critical difference:
# - in the bash function case (test 2), it is killed by HUP, which is sent by bash itself
#   in responce to receiving TERM
# - in the case of a script, the script is killed by TERM sent from timeout
function test03()
{
    (
        scriptdir=$( dirname "$0" )/private
        script="$scriptdir"/test03-script
        [[ -x "$script" ]] || exit 1
        export output_file="$output_dir/test03.log"
        # will kill the function by timer (which is shorter than expected run-time)
        timeout -k 10 -s TERM 5 "$script" &
        wait $!
    )
}
test03 ; echo "test[3]/exit/status=$?" ; echo "test[3]/output=\""$( cat "$output_dir"/test03.log )"\""

function test04_outer_handler()
{
    echo "handle $1"
    exit 0
}
export -f test04_outer_handler

function test04_to_execute()
{
    comma-nap 10 &
    wait $!
}
export -f test04_to_execute

function test04_to_be_killed()
{
    trap 'test04_outer_handler TERM' SIGTERM
    trap 'test04_outer_handler HUP'  SIGHUP
    trap 'test04_outer_handler PIPE' SIGPIPE
    trap 'test04_outer_handler INT'  SIGINT
    #
    comma_execute_and_wait "bash -c test04_to_execute" > $output_file
}
export -f test04_to_be_killed

# set up signal handlers, then run comma_execute_and_wait, and kill by a signal;
# after terminating the background job, control is returned to the original signal handler
function test04()
{
    (
        export output_file="$output_dir/test04.log"
        # will kill the function by timer (which is shorter than expected run-time)
        timeout -k 10 -s TERM 5 bash -c test04_to_be_killed &
        wait $!
    )
}
test04 ; echo "test[4]/exit/status=$?" ; echo "test[4]/output=\""$( cat "$output_dir"/test04.log )"\""

# similar to test03, but specify a custom signal
function test05()
{
    (
        scriptdir=$( dirname "$0" )/private
        script="$scriptdir"/test05-script
        [[ -x "$script" ]] || exit 1
        export output_file="$output_dir/test05.log"
        # will kill the function by timer (which is shorter than expected run-time)
        timeout -k 10 -s USR1 5 "$script" &
        wait $!
    )
}
test05 ; echo "test[5]/exit/status=$?" ; echo "test[5]/output=\""$( cat "$output_dir"/test05.log )"\""
