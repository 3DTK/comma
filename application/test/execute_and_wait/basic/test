#!/bin/bash

source $( which comma-application-util ) || exit 1

export output_dir="output"
rm -rf "$output_dir" || exit 1
mkdir -p "$output_dir" || exit 1

# Tests to consider:
#
# - run a verbose utility like "comma-nap" to completion
#   verify that the test program indeed was executed
# - same with a bash function
# - same with passing arguments and variables to a bash function
#
# - run comma-nap and terminate by timeout; verify that the command-to-execute
#   was terminated, and that that expected status is returned
# - run comma-nap and kill comma_execute_and_wait; verify that command being
#   executed is killed, and that the expected exit status is returned
#
# - set up handlers, then run comma_execute_and_wait, and kill by a signal;
#   verify that control is returned to the original handler
#
# - specify different signal list: trap a custom signal and report

function test01()
{
    comma_execute_and_wait "comma-nap 10" >/dev/null
}

function test02()
{
    comma_execute_and_wait --max-wait=5 "comma-nap 10" >/dev/null
}

function test03()
{
    comma_execute_and_wait --signals="TERM,USR1" "comma-nap 10" >/dev/null
}

function test04_to_execute()
{
    { comma-nap $nap_time && echo "OK" ; } > $output_file
}
export -f test04_to_execute

function test04()
{
    export output_file="$output_dir/test04.log"
    export nap_time=5
    comma_execute_and_wait "bash -c test04_to_execute" >/dev/null
}

function test05()
{
    export output_file="$output_dir/test05.log"
    export nap_time=10
    comma_execute_and_wait --timeout=5 "bash -c test04_to_execute" >/dev/null
}

test01 ; echo "test[1]/exit/status=$?"
test02 ; echo "test[2]/exit/status=$?"
test03 ; echo "test[3]/exit/status=$?"
test04 ; echo "test[4]/exit/status=$?" ; echo "test[4]/output=\""$( tail -n 1 "$output_dir"/test04.log )"\""
test05 ; echo "test[5]/exit/status=$?" ; echo "test[5]/output=\""$( tail -n 1 "$output_dir"/test05.log )"\""
