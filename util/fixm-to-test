#!/bin/bash

name=$( basename $0 )
tolerances_file="$HOME/wwwTests/tolerance_defaults.txt"

simple_usage()
{
    echo "Usage: $name [fixm-file] [-h|--help] [-t|--tolerances=<file>]" >&2
    if [[ $# != 0 ]]; then exit $1; fi
}

usage()
{
    simple_usage
    cat >&2 <<EOF

Appends tolerance ("+/-") values to FIXM data in path=value format.

If no input file is specified, reads from standard input.

Tolerance values are listed in a file with format: <field> <tolerance>, where <field> is a regular expression
and <tolerance> is a number (with an optional "%", e.g. "5%"). Blank lines and comments (lines starting with "#")
in the tolerance file are ignored.

Note that the regular expressions in this file implicitly have "$" appended (i.e. they match the end of the
field name) and "(^|/)" prepended (i.e. they either match the start of the field name, or follow "/").

Options:

    -h|--help           Show this help
    -t|--tolerances=    Specify tolerances file to use; default: $tolerances_file

EOF
    if [[ $# != 0 ]]; then exit $1; fi
}

input=

while [[ $# -gt 0 ]]; do
    arg="${1#*=}"
    case "$1" in
        -h|--help) usage 0;;
        -t=*|--tolerances=*) tolerances_file=$arg;;

        -*)        echo "$name: unrecognized option '$1'" >&2; exit 1;;

        *)         if [[ -z "$input" ]]; then input=$1;
                   else echo "$name: unexpected argument '$1'" >&2; exit 1; fi;;
    esac
    shift
done

if [[ ! -f "$tolerances_file" ]]; then
    echo "$name: warning: cannot open tolerances file '$tolerances_file'; not setting any tolerance values" >&2
    cat $input
    exit 0
fi

# DF:
# - if rhs is quoted, always ignore
# - add "$" to end of input patterns and "(^|/)" to start
# - tolerance value of 0 means ignore (no tolerance)
# - more specific patterns come earlier in the file
# - allow comments and blank lines in the pattern file
# - maybe allow "*" for ".*" (but leave ")*" unchanged, so can still use "*")

( cat "$tolerances_file"; echo "@:@:@"; cat $input ) | awk '
BEGIN { num_patterns = 0; }
/^@:@:@$/ { reading_input = 1; FS = "="; next; }
/^#/ || NF == 0 { next; }    # skip blank lines and comments

{
    if (reading_input) \
    {
        # note that the fields separator (FS) is "="
        if (NF != 2 || $2 ~ "\"" || $2 == "0") { print $0; } \
        else
        {
            found = 0;
            for (p = 0;p < num_patterns;p++)
            {
                if ($1 ~ pattern[p]) \
                {
                    if (tolerance[p] == 0) { break; }   # tolerance 0 means do not use a tolerance
                    print $0 " +/- " tolerance[p];
                    found = 1;
                    break;
                }
            }
            if (!found) { print $0; }
        }
    }
    else
    {
        # reading tolerances
        if (NF != 2) \
        {
            print "'$name': error on line " NR " of '$tolerances_file': expected field name and tolerance value, found: " $0 | "cat 1>&2";
            exit 1;
        }

        if ($2 !~ "^[0-9.][0-9.]*%?$") \
        {
            print "'$name': error on line " NR " of '$tolerances_file': expected numeric tolerance value but found: " $2 | "cat 1>&2";
            exit 1;
        }

        # make the pattern start at a word boundary (start of string or after "/") and be at the end
        pattern[num_patterns] = "(^|/)" $1 "$";
        tolerance[num_patterns] = $2;
        ++num_patterns;
    }
}
' || exit 1

