#!/bin/bash

source $( which comma-application-util )
source $( which comma-test-util )

name=$( basename $0 )

# defaults
qstorage="/mnt/q-storage"
max_parallel=1
max_wait=600

function default_options()
{
    echo "path=$qstorage"
    echo "max_parallel=$max_parallel"
    echo "max_wait=$max_wait"
}

function description()
{
    cat <<EOF
--help,-h; show this help
--debug; much more debug output
--quiet,-q; output only failures
--until-first-failure,-f; exit after the first failure
--path=[<dir>]; q-storage directory, default: '$qstorage'
--max-parallel=[<N>]; run up to N tests in parallel; default: $max_parallel
--max-wait=[<time>]; maximal time to wait for available CPUs before failing a test, default: ${max_wait}s
EOF
}

function usage_()
{
    echo -e "Usage: comma-test-run [<options>]" >&2
    echo >&2
    echo -e "Searches for and executes tests under the current directory." >&2
    echo >&2
    echo -e "Finds subdirectories containing the files ${brown}test${none}, ${brown}input${none} or ${brown}expected${none}. Execute 'test', then either:" >&2
    echo -e "    (a) if 'expected' exists, compare its contents to the output of 'test' (\"path=value\" format)" >&2
    echo -e "    (b) otherwise the success of the test depends on the exit status of the 'test' script." >&2
    echo >&2
    echo -e "File 'input', if exists, is fed to the stdin of the test script." >&2
    echo >&2
    echo -e "If there is an 'input' or 'expected' file but no 'test' in the same directory, the 'test' script in the" >&2
    echo -e "closest parent directory is used. If there is a 'test' by itself with no 'input' or 'expected' file," >&2
    echo "it is only executed if there is no subdirectory containing 'input', 'expected' or 'test'." >&2
    echo >&2
    echo -e "Returns 0 if all tests succeed, or non-zero if any of the tests fail." >&2
    echo >&2
    echo -e "Note: in quiet mode, only the messages containing the word \"failed\" will be displayed" >&2
    echo >&2
    echo -e "Options:" >&2
    description | sed 's/^/    /g' >&2
    echo >&2
    echo -e "Disabling tests:" >&2
    echo -e "    to disable tests in a directory and all its subdirectories" >&2
    echo -e "    create an empty file named ${brown}disabled${none} in that directory" >&2
    echo >&2
    echo -e "Load-balancing and serializing tests:" >&2
    echo -e "    to indicate a CPU-heavy test, create a file named ${brown}parallel${none} in the test directory" >&2
    echo -e "    and specify the number of CPUs to be used by the test; value -1 indicates 'all' CPUs," >&2
    echo -e "    i.e., serializing the test" >&2
    echo >&2
    exit 1
}

# comma-test-util is in the same folder as this script
source "${0%run}util"

function error_()
{
    tput bold
    high="\033[1;31m"
    normal="\033[0m"
    echo -e "$high$1$normal" >&2
    tput sgr0
}
export -f error_

function message_()
{
    if [[ "$options_quiet" != "1" ]] ; then tput bold ; echo $1 >&2 ; tput sgr0 ; fi
}
export -f message_

function dump_file_()
{
    if [[ "$options_quiet" != "1" ]] ; then cat "$1" >&2 ; fi
}
export -f dump_file_

function warning_()
{
    if [[ "$options_quiet" != "1" ]] ; then tput bold ; echo -e "${brown}$1${none}" >&2  ; tput sgr0 ; fi
}
export -f warning_

function disabled_()
{
    if [[ -f "$1/disabled" ]] ; then return 0 ; fi
    d=$( dirname $1 )
    if [[ "$d" == "$1" ]] ; then return 1 ; fi
    disabled_ $d
    return $?
}
export -f disabled_

# copy input to output, and return failure (1) if there was any output
function fail_on_output()
{
    if grep "."; then return 1; else return 0; fi
}
export -f fail_on_output

# return a string with "\" before any characters that are special in regular expressions
function escape_special_chars()
{
    echo $* | sed 's/[].*|&^$[]/\\&/g'
}

# arguments: a list of directories containing "test", "input" and "expected" files
# Outputs the same list, excluding any directories that
# (1) contain only "test" (no "expected" or "input" file), and
# (2) have at least one subdirectory containing another test
# This is so that it is possible to have a generic "test" script in the base directory that is not
# executed in that directory.
function exclude_generic_tests()
{
    local dir_list=$*
    local result_list=()

    for dir in $dir_list; do
        if [[ -f "$dir/test" && ! -f "$dir/input" && ! -f "$dir/expected" && ! -f "$dir/disabled" ]]; then
            local pattern="^$( escape_special_chars "$dir" )/."
            if echo $dir_list | fmt -1 | grep -q "$pattern"; then
                if [[ "$options_debug" != "" ]] ; then echo "Excluding generic test '$dir/test'" >&2; fi
                continue
            fi
        fi
        result_list+=( $dir )
    done

    echo "${result_list[@]}"
}

# find "test" file inside a path, checking in each subdirectory (starting from the full path)
# arguments: <path> <file to find>
function closest_test_in_path()
{
    local path=$1
    local file="test"

    # sanity check (and avoid infinite loop)
    if [[ -z "$path" ]]; then echo "$name: error: empty path in closest_file_in_path()" >&2; exit 1; fi
    # get canonical name (so path always starts with "/")
    path=$( readlink -e "$path" )

    while true; do
        if [[ -d "$path/$file" ]]; then
            echo "$name: warning: \"$path/$file\" is a directory (expected an executable script); ignoring" >&2
        elif [[ -f "$path/$file" ]]; then
            if [[ -x "$path/$file" ]]; then echo $path/$file; break
            else echo "$name: warning: \"$path/$file\" is not executable; ignoring" >&2; fi
        elif [[ $path == "/" ]]; then break
        fi
        path=$( dirname "$path" )
    done
}
export -f closest_test_in_path

# "dirname" with multiple arguments allowed (since some versions of "dirname" don't allow them)
function get_dirnames()
{
    for i in $*; do dirname $i; done
}

function stats_init()
{
    stats="$(pwd)/stats"
    stats_progress_csv="$stats/progress.csv"
    stats_elapsed_path_value="$stats/elapsed.csv"
    rm -rf $stats
    mkdir $stats
    touch "$stats_progress_csv"
}

function stats_finalize()
{
    if [[ -f $stats_progress_csv ]] ; then cat $stats_progress_csv | comma-progress --elapsed > $stats_elapsed_path_value ; fi
}

# each test may specify the desired number of CPUs:
#   0      - does not matter, very lightweight
#   n > 0  - n CPUs
#  -1      - all CPUs (serial test)
# default is 1
function get_parallel_requirements()
{
    [[ -f ./parallel ]] && {
        cat ./parallel
    } || {
        echo 1
    }
}
export -f get_parallel_requirements

function occupy_cpus()
{
    local dir=$1
    local num_to_take=$2
    (( $num_to_take == 0 )) && return 0   # default: always can run quick tests, do not change CPU count
    (
        flock -x 8
        currently_occupied=$( tail -n 1 "$comma_test_run_cpucount_flock" )
        [[ -n "$options_debug" ]] && {
            num_to_take_str=$num_to_take
            (( $num_to_take == -1 )) && num_to_take_str="all $options_max_parallel"
            currently_occupied_str=$currently_occupied
            (( $currently_occupied == -1 )) && currently_occupied_str="all $options_max_parallel"
            echo "$name (occupy_cpus): need $num_to_take_str CPUs, have $currently_occupied_str occupied" >&2
        }
        (( $currently_occupied == -1 )) && exit 1
        (( $num_to_take == -1 && $currently_occupied != 0 )) && exit 1
        (( $currently_occupied == 0 )) && { echo $num_to_take >&8; exit 0; }
        next_occupied=$(( $num_to_take + $currently_occupied ))
        (( $next_occupied > $options_max_parallel )) && exit 1
        echo $next_occupied >&8
        exit 0
    ) 8>>"$comma_test_run_cpucount_flock"
    local result=$?
    return $result
}
export -f occupy_cpus

function release_cpus()
{
    local dir=$1
    local num_to_yield=$2
    (( $num_to_yield == 0 )) && return 0   # default: always can run quick tests, do not change CPU count
    (
        flock -x 8
        currently_occupied=$( tail -n 1 "$comma_test_run_cpucount_flock" )
        [[ -n "$options_debug" ]] && {
            num_to_yield_str=$num_to_yield
            (( $num_to_yield == -1 )) && num_to_yield_str="all $options_max_parallel"
            currently_occupied_str=$currently_occupied
            (( $currently_occupied == -1 )) && currently_occupied_str="all $options_max_parallel"
            echo "$name (release_cpus): have $currently_occupied_str CPUs occupied, yield $num_to_yield_str" >&2
        }
        (( $currently_occupied == -1 )) && {
            (( $num_to_yield != -1 )) && { echo "Major logic error" >&2; exit 1; }
            echo 0 >&8
            exit 0
        }
        next_occupied=$(( $currently_occupied - $num_to_yield ))
        (( $next_occupied < 0 )) && next_occupied=0
        echo $next_occupied >&8
        exit 0
    ) 8>>"$comma_test_run_cpucount_flock"
    local result=$?
    return $result
}
export -f release_cpus

# process command line...
if (( $( comma_options_has --help $@ ) || $( comma_options_has -h $@ ) )) ; then usage_ ; fi
comma_path_value_to_var  --prefix=options < <( default_options )
comma_path_value_to_var --prefix=options < <( description | comma-options-to-name-value $@ )
# and perform sanity check
[[ ! -d "$options_path" ]] && { error_ "$name: q-storage '$options_path' not found"; exit 1; }
(( $options_max_parallel < 1 )) && { error_ "$name: number of parallel tests $options_max_parallel < 1"; exit 1; }
(( $options_max_wait < 1 )) && { error_ "$name: wait time $options_max_wait < 1s"; exit 1; }
export options_max_parallel options_max_wait options_debug options_quiet options_path options_until_first_failure

if [[ "$options_quiet" != "1" ]] ; then grep_failed_=cat ; else grep_failed_="grep failed" ; fi

# to run tests in parallel, we need to lock stats_progress_csv and/or stdout/stderr
# this is the global flock name
comma_test_run_output_flock=$( mktemp )
export comma_test_run_output_flock

# keep the number of CPUs currently occupied/available
# this is the global file name; access serialized via flocks
comma_test_run_cpucount_flock=$( mktemp )
export comma_test_run_cpucount_flock
echo 0 >"$comma_test_run_cpucount_flock"

trap "error_ 'comma-test-run: received signal, terminating...' >&2 ; is_shutdown=true" SIGINT SIGTERM
trap "stats_finalize; final_words" EXIT

basedir=$( pwd )
result=0

stats_init

# this function runs the actual test
# arguments:
#     name                    - top-level script name, use as output prefix
#     path to q-storage       - where the data are
#     stats file name         - will write start/stop time into this file
#     verbosity flag          - auxiliary, chatter more/less
#     'grep failed' routine   - filters/not stderr output
#     total                   - total number of tests
#     count                   - sequential test number
#     test directory          - will cd and run the test inside
function run_single_test()
{
    local name=$1
    local path=$2
    [[ -n "$path" ]] && path="--path=$path"
    local stats_progress=$3
    local verbose=$4
    local grep_failed_=$5
    local total=$6
    local count=$7
    local dir=$8

    source $( which comma-application-util ) || return 1
    source $( which comma-test-util ) || return 1

    local counter="$count of $total"

    # create a unique file for local comma_progress output; will append to the main output at the end
    local our_stats_progress="$stats_progress.$(mktemp -u XXXXXX)"
    >"$our_stats_progress"

    # create a unique file for redirecting all output; will append to the main output at the end
    local our_stdout_log=$( mktemp --tmpdir=$( dirname "$stats_progress" ) )
    exec 3>&1 4>&2 1>"$our_stdout_log" 2>&1

    local test_exec basedir
    local result=0

    if disabled_ "$dir" ; then
        warning_ "$name: test $counter: $dir: disabled"
    else
        test_exec=$( closest_test_in_path "$dir" )
        if [[ -z "$test_exec" ]]; then
            error_ "$name: error: no \"test\" script found in any parent directory of $dir" >&2
            result=1
        else
            message_ "$name: test $counter: $dir: running..."

            basedir=$( pwd )

            ## Comment out for now: the exact usage to be discussed, it is confusing and can be taken as a sign of error
            ##[ -f "$dir/readme" ] && dump_file_ "$dir/readme"
            cd "$dir"
            local parallel wait_time sleep_time
            wait_time=0
            parallel=$( get_parallel_requirements )
            while true ; do
                occupy_cpus "$dir" $parallel
                (( $? != 0 )) && {
                    (( $wait_time >= $options_max_wait )) && { echo "$name: in '$dir', could not get $parallel CPUs for ${wait_time}s, failed to run" >&2; result=1; break; }
                    sleep_time=$[ ( $RANDOM % 10 )  + 1 ]
                    wait_time=$(( $wait_time + $sleep_time ))
                    sleep ${sleep_time}s
                    continue
                }
                if [ -f ./input ] ; then cat ./input ; fi \
                    | comma_progress_named "$our_stats_progress" "$dir" "$test_exec" "$path" "$verbose" 2> >( "$grep_failed_" >&2 ) \
                    | if [[ -f ./expected ]]; then comma-test-match ./expected 2>&1 | fail_on_output; else cat > /dev/null; fi
                if status_ok ; then message_ "$name: test $counter: $dir: succeeded" ; else result=1 ; error_ "$name: $dir: failed" ; fi
                release_cpus "$dir" $parallel
                break
            done
            cd $basedir
        fi
    fi

    # serialize all access to global resources: stats file, stdout/err
    (
        flock -x 8
        cat "$our_stats_progress" >> "$stats_progress"
        cat "$our_stdout_log" >&3
        local msg="test $count in '$dir': "
        (( $result == 0 )) && { msg+="success"; } || { msg+="failed"; }
        echo "$msg" >&8
    ) 8>>"$comma_test_run_output_flock"

    rm -f "$our_stats_progress"
    rm -f "$our_stdout_log"

    return $result
}
export -f run_single_test

function process_accumulated_tests()
{
    xargs -n2 | xargs -P $options_max_parallel -I{} bash -c run_single_test\ "'$name'"\ "'$options_path'"\ "'$stats_progress_csv'"\ "'$verbose'"\ "'$grep_failed_'"\ "'$test_scripts_count'"\ {}
    status_ok || {
        result=1
        [[ "$options_until_first_failure" == "true" ]] && exit 1
    }
}

function count_failures()
{
    (
        flock -x 8
        grep -c "failed" "$comma_test_run_output_flock"
    ) 8>>"$comma_test_run_output_flock"
}

function final_words()
{
    failed_count=$( count_failures )
    local afterword=
    [[ "$is_shutdown" == "true" ]] && afterword=" (untill killed)"
    if [[ "$failed_count" == 0 ]] ; then message_ "$name: in subdirectories of $( pwd ): succeeded${afterword}" ; else error_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): $failed_count test[s] out of $test_scripts_count failed${afterword}" ; fi
    [[ -n "$options_debug" ]] && { echo "$name: detailed breakdown:" >&2 ; cat "$comma_test_run_output_flock" >&2; }
    rm -f "$comma_test_run_output_flock"
    rm -f "$comma_test_run_cpucount_flock"
}

# to run 

# search for directories containing either "test", "input" or "expected";
# if "test" is absent, use the "test" in the closest parent directory

test_script_dirs=$( exclude_generic_tests $( get_dirnames $( find . -name "test" -or -name "input" -or -name "expected" ) 2> /dev/null | sort -u ) )
test_scripts_count=$( echo $test_script_dirs | wc -w )
count=0
failed_count=0
#if [[ "$options_debug" != "" ]] ; then verbose="--verbose" ; fi # quick and dirty
if (( $test_scripts_count > 0 )) ; then
    message_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): running..."
    for dir in $test_script_dirs ; do
        if [[ -n "$is_shutdown" ]] ; then error_ "comma-test-run: terminated" >&2 ; exit 1 ; fi
        (( ++count ))
        echo "$count  \"$dir\""
    done | process_accumulated_tests
else
    echo -e "${brown}$name: warning: no tests found in $( pwd )${none}" >&2
fi

exit $result

# for batch modification of test cases
# for file in `find -name "expected"` ; do
#     echo $(dirname $file)
#     #cat $file | awk '{print "# "$0}' > $file".txt"
#     git_ignore=$(dirname $file)"/.gitignore"
#     echo "output" > $git_ignore
#     echo "stderr.log" >> $git_ignore
#     cat $git_ignore
# #   rm $git_ignore
#     #mv $file".txt" $file
# done
