#!/bin/bash

# This script provides Bash functions for coordination of system
# resources usage across a pool of workers (processes).

# Read a json file as text stream on stdin and in the given path (2nd argument)
# append the pid (1st argument) to the end of []-enclosed list (insert into
# the list if empty); output the resulting json to stdout. Path argument is
# optional, default is "processes/queue". Operation shall be invoked under
# external synchronization mechanism.
function enqueue_pid()
{
    local pid=$1
    local path=$2
    local default_path="processes/queue"
    path=${path:-"$default_path"}
    path="^${path//\//\\\/}="
    name-value-convert --from json --to path-value \
        | sed --regexp-extended "/$path/s/\[(.+)\]/\[\1,$pid\]/;/$path/s/\[\]/\[$pid\]/" \
        | name-value-convert --from path-value --to json
}

# Opposite to enqueue_pid above. Remove the given pid from the list.
function dequeue_pid()
{
    local pid=$1
    local path=$2
    local default_path="processes/queue"
    path=${path:-"$default_path"}
    path="^${path//\//\\\/}="
    name-value-convert --from json --to path-value \
        | sed --regexp-extended "/$path/s/\[$pid,(.+)\]/\[\1\]/;/$path/s/\[(.+),$pid\]/\[\1\]/;/$path/s/\[(.+),$pid,(.+)\]/\[\1,\2\]/;/$path/s/\[$pid\]/\[\]/" \
        | name-value-convert --from path-value --to json
}

# Read a json file as text stream on stdin. Check the position of the given
# PID (1st argument) in the waiting list described by path (optional second
# argument). Echo the positional index counted from 0, if found. Otherwise,
# echo "-1".
function check_pid_position()
{
    local pid=$1
    local path=$2
    local default_path="processes/queue"
    path=${path:-"$default_path"}
    local list
    list=$( name-value-get --from json "$path" | sed "s/^\[/ /;s/\]\$/ /;s/,/ /g" )
    if echo "$list" | grep -q " $pid " ; then
        echo "$list" | sed "s/ $pid .*\$//" | wc -w
    else
        echo "-1"
    fi
}

# Tell if the queue is empty. Read book-keeping file in json format on stdin.
# Take an optional argument, path to the queue. Exit with status 0 for empty
# queue and status 1 for non-empty.
function empty_queue()
{
    local path=$1
    local default_path="processes/queue"
    path=${path:-"$default_path"}
    local list
    list=$( name-value-get --from json "$path" | sed "s/^\[//;s/\]\$//;s/ //g" )
    [[ -z "$list" ]]
}

# Output the most commonly used system resources: number of CPUs, total RAM,
# size, total shared memory size.
function total_system_resources()
{
    local cpus memory_main memory_shared memory_limits fcn_name
    fcn_name=${name:-"total_system_resources"}
    cpus=$( grep -c '^processor' /proc/cpuinfo )
    (( $? == 0 || $cpus > 0 )) || { echo "$fcn_name: cannot grep '/proc/cpuinfo' for the number of processors" >&2; return 1; }
    #
    memory_limits=$( ipcs -ml 2>/dev/null )
    (( $? == 0 )) || { echo "$fcn_name: cannot determine memory limits by calling ipcs" >&2; exit 1; }
    memory_shared=$( echo "$memory_limits" | sed '/shared/!d;s/.* //g' )
    (( $memory_shared > 0 )) || { echo "$fcn_name: cannot determine shared memory size" >&2; exit 1; }
    memory_shared=$(( $memory_shared * 1024 ))
    #
    memory_main=$( cat /proc/meminfo | sed -n --regexp-extended "s/^MemTotal: *(.*) .*$/\1/p" )
    (( $memory_main > 0 )) || { echo "$fcn_name: cannot determine total memory size" >&2; exit 1; }
    memory_main=$(( $memory_main * 1024 ))
    #
    echo "resources/cpus=\"$cpus\""
    echo "resources/memory/main=\"$memory_main\""
    echo "resources/memory/shared=\"$memory_shared\""
}

# Initialize a json file listing the currently occupied system resources
# and a list of processes waiting for them.
#
# Input: resource book-keeping file name. Read on stdin resource description
# in path-value format. No output. Write the book-keeping file in json format.
#
# See below for a variant of this function that is safe for parallel use.
function initialize_resources()
{
    local counter=$1
    (
        sed 's/=.*$/="0"/'
        echo 'processes/queue="[]"'
    ) | name-value-convert --from path-value --to json > "$counter"
}

# Given a description of requested resources (1st argument), currently occupied
# resources (2nd argument) and maximal allowed resources (3rd argument), check
# that resources can be acquired ( occupied + requested < maximum ).
#
# If yes, check if any process is already waiting for resources. If yes, and if
# that process has the same PID as ourselves (4th argument), and it is the first
# in the queue, then:
# - remove this PID from the waiting queue,
# - increase the counters of occupied resources,
# - return 0.
# No output is produced.
#
# If the PID is already in the waiting list, but not at the first position, do not
# modify any files, output "wait" to stdout, and return 1.
#
# If request exceeds the limits, or if the waiting list is not empty and PID is not
# on the list, append the PID to the list of waiting processes kept in the counter
# file, output "wait" to stdout and return 1.
#
# Any other combination of non-zero exit status and non-empty output indicate
# a general system error.
#
# Optional 5th argument specifies the json path to the []-enclosed list of waiting
# processes in the counter file. Default path defined in enqueue/dequeue functions.
#
# Resources are described in json files like:
# {
#     "resources":
#     {
#         "cpus": "8",
#         "memory":
#         {
#             "main": "1000000",
#             "shared": "500000"
#         }
#     }
# }
#
# See below for a variant of this function that is safe for parallel use.
function acquire_resources()
{
    local request=$1
    local counter=$2
    local maximum=$3
    local pid=$4
    local path=$5

    local next position can_acquire any_waiting
    # hope for the best if asking for more than available
    if name-value-calc "$request" "$maximum" --more --json --status ; then
        request="$maximum"
    fi
    next=$( name-value-calc "$counter" "$request" --add --json )
    (( $? == 0 )) || { echo "$name: cannot add resources" >&2; return 1; }
    can_acquire=$( name-value-calc <( echo "$next" ) "$maximum" --less-or-equal --json --echo )
    (( $? == 0 )) || { echo "$name: cannot compare resources" >&2; return 1; }
    position=$( cat "$counter" | check_pid_position "$pid" "$path" )
    (( $? == 0 )) || { echo "$name: cannot check pid position" >&2; return 1; }
    any_waiting=$( cat "$counter" | empty_queue && echo 0 || echo 1 )
    (( $? == 0 )) || { echo "$name: check for empty queue failed" >&2; return 1; }
    if [[ $any_waiting == 1 ]] ; then                 # queue is not empty, can acquire only if
        if [[ $position == 0 ]] ; then                # we are the first in line and
            if [[ $can_acquire == 1 ]] ; then         # there are enough resources
                next=$( echo "$next" | dequeue_pid "$pid" "$path" )
                (( $? == 0 )) || { echo "$name: cannot dequeue from waiting list" >&2; return 1; }
                echo "$next" > "$counter"
                return 0
            else                                      # otherwise just keep waiting
                echo "wait"
                return 1
            fi
        else
            if [[ $position == -1 ]] ; then           # but if we are not in the queue, append
                next=$( cat "$counter" | enqueue_pid "$pid" "$path" )
                (( $? == 0 )) || { echo "$name: cannot enqueue for waiting" >&2; return 1; }
                echo "$next" > "$counter"
            fi
            echo "wait"
            return 1
        fi
    else                                              # if no-one is waiting
        if [[ $can_acquire == 1 ]] ; then             # easy if enough resources
            echo "$next" > "$counter"
            return 0
        else                                          # otherwise append to the queue
            next=$( cat "$counter" | enqueue_pid "$pid" "$path" )
            (( $? == 0 )) || { echo "$name: cannot enqueue for waiting" >&2; return 1; }
            echo "$next" > "$counter"
            echo "wait"
            return 1
        fi
    fi
}

# Helper function ensures that all resource counters are non-negative.
# Takes resource description on stdin in json format, outputs sanitized
# description on stdout.
function non_negative_resources()
{
    name-value-convert --from json --to path-value \
        | sed '/^resources\//s/="-[0-9][0-9]*"$/="0"/' \
        | name-value-convert --from path-value --to json
}

# Opposite to acquire_resources. Input: description of resources being
# released (1st argument), resource counter (2nd argument) in json format.
# No output. Write an updated counter file.
#
# See below for a variant of this function that is safe for parallel use.
function release_resources()
{
    local request=$1
    local counter=$2
    local next
    next=$( name-value-calc "$counter" "$request" --subtract --json )
    (( $? == 0 )) || { echo "$name: cannot subtract resources" >&2; return 1; }
    next=$( echo "$next" | non_negative_resources )
    (( $? == 0 )) || { echo "$name: cannot sanitize resources" >&2; return 1; }
    echo "$next" > "$counter"
    return 0
}

# General synchronization function. Takes on input a lock file name to be used
# in a flock call (this file will be truncated to zero) and the command to be
# executed with all the arguments. Example:
#
#     serialize /tmp/mylock myfcn --option1 "$value1" "$arg1" ...
#
# Note: do not re-direct output of the function being protected. Do all writes
# within a function while it is protected by the serialization lock.
function serialize()
{
    local lock=$1
    shift
    (
        flock -x 8
        $@
    ) 8>"$lock"
}

# Lock-protected versions of the relevant functions from this script.
function locked_initialize_resources()
{
    serialize $1 initialize_resources $2
}

function locked_acquire_resources()
{
    serialize $1 acquire_resources $2 $3 $4 $5 $6
}

function locked_release_resources()
{
    serialize $1 release_resources $2 $3
}
