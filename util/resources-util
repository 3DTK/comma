#!/bin/bash

# This script provides Bash functions for coordination of system
# resources usage across a pool of workers (processes).

# Read a json file as text stream on stdin and in the given path (2nd argument)
# append the pid (1st argument) to the end of []-enclosed list (insert into
# the list if empty); output the resulting json to stdout. Path argument is
# optional, default is "processes/queue". Operation shall be invoked under
# external synchronization mechanism.
function enqueue_pid()
{
    local pid=$1
    local path=$2
    local default_path="^processes\/queue="
    path=${path:-"$default_path"}
    name-value-convert --from json --to path-value \
        | sed --regexp-extended "/$path/s/\[(.+)\]/\[\1,$pid\]/;/$path/s/\[\]/\[$pid\]/" \
        | name-value-convert --from path-value --to json
}

# Opposite to enqueue_pid above. Remove the given pid from the list.
function dequeue_pid()
{
    local pid=$1
    local path=$2
    local default_path="^processes\/queue="
    path=${path:-"$default_path"}
    name-value-convert --from json --to path-value \
        | sed --regexp-extended "/$path/s/\[$pid,(.+)\]/\[\1\]/;/$path/s/\[(.+),$pid\]/\[\1\]/;/$path/s/\[(.+),$pid,(.+)\]/\[\1,\2\]/;/$path/s/\[$pid\]/\[\]/" \
        | name-value-convert --from path-value --to json
}

# Output the most commonly used system resources: number of CPUs, total RAM,
# size, total shared memory size.
function total_system_resources()
{
    local cpus memory_main memory_shared memory_limits fcn_name
    fcn_name=${name:-"total_system_resources"}
    cpus=$( grep -c '^processor' /proc/cpuinfo )
    (( $? == 0 || $cpus > 0 )) || { echo "$fcn_name: cannot grep '/proc/cpuinfo' for the number of processors" >&2; return 1; }
    #
    memory_limits=$( ipcs -ml 2>/dev/null )
    (( $? == 0 )) || { echo "$fcn_name: cannot determine memory limits by calling ipcs" >&2; exit 1; }
    memory_shared=$( echo "$memory_limits" | sed '/shared/!d;s/.* //g' )
    (( $memory_shared > 0 )) || { echo "$fcn_name: cannot determine shared memory size" >&2; exit 1; }
    memory_shared=$(( $memory_shared * 1024 ))
    #
    memory_main=$( cat /proc/meminfo | sed -n --regexp-extended "s/^MemTotal: *(.*) .*$/\1/p" )
    (( $memory_main > 0 )) || { echo "$fcn_name: cannot determine total memory size" >&2; exit 1; }
    memory_main=$(( $memory_main * 1024 ))
    #
    echo "resources/cpus=\"$cpus\""
    echo "resources/memory/main=\"$memory_main\""
    echo "resources/memory/shared=\"$memory_shared\""
}

# Initialize a json file listing the currently occupied system resources
# and a list of processes waiting for them.
#
# Input: resource book-keeping file name. Read on stdin resource description
# in path-value format. No output. Write the book-keeping file in json format.
#
# See below for a variant of this function that is safe for parallel use.
function initialize_resources()
{
    local counter=$1
    (
        sed 's/=.*$/="0"/'
        echo 'processes/queue="[]"'
    ) | name-value-convert --from path-value --to json > "$counter"
}

# Given a description of requested resources (1st argument), currently occupied
# resources (2nd argument) and maximal allowed resources (3rd argument), check
# that resources can be acquired ( occupied + requested < maximum ).
#
# If yes, increase the counters of occupied resources and return 0. No output is
# produced.
#
# If request exceeds the limits, append the caller id (such as PID, 4th argument)
# to the list of waiting processes kept in the counter file, output "wait" to stdout
# and return 1.
#
# Any other combination of non-zero exit status and non-empty output indicate
# a general system error.
#
# Optional 5th argument specifies the json path to the []-enclosed list of waiting
# processes in the counter file. Default path defined in enqueue/dequeue functions.
#
# Resources are described in json files like:
# {
#     "resources":
#     {
#         "cpus": "8",
#         "memory":
#         {
#             "main": "1000000",
#             "shared": "500000"
#         }
#     }
# }
#
# See below for a variant of this function that is safe for parallel use.
function acquire_resources()
{
    local request=$1
    local counter=$2
    local maximum=$3
    local pid=$4
    local path=$4

    local next
    next=$( name-value-calc "$counter" "$request" --add --json )
    (( $? == 0 )) || { echo "$name: cannot add resources" >&2; return 1; }
    if name-value-calc <( echo "$next" ) "$maximum" --less-or-equal --json --status ; then
        (( $? == 0 )) || { echo "$name: cannot compare resources" >&2; return 1; }
        next=$( echo "$next" | dequeue_pid "$pid" "$path" )
        (( $? == 0 )) || { echo "$name: cannot dequeue from waiting list" >&2; return 1; }
        echo "$next" > "$counter"
        return 0
    else
        next=$( cat "$counter" | enqueue_pid "$pid" "$path" )
        (( $? == 0 )) || { echo "$name: cannot enqueue for waiting" >&2; return 1; }
        echo "$next" > "$counter"
        echo "wait"
        return 1
    fi
}

# Helper function ensures that all resource counters are non-negative.
# Takes resource description on stdin in json format, outputs sanitized
# description on stdout.
function non_negative_resources()
{
    name-value-convert --from json --to path-value \
        | sed '/^resources\//s/="-[0-9][0-9]*"$/="0"/' \
        | name-value-convert --from path-value --to json
}

# Opposite to acquire_resources. Input: description of resources being
# released (1st argument), resource counter (2nd argument) in json format.
# No output. Write an updated counter file.
#
# See below for a variant of this function that is safe for parallel use.
function release_resources()
{
    local request=$1
    local counter=$2
    local next
    next=$( name-value-calc "$counter" "$request" --subtract --json )
    (( $? == 0 )) || { echo "$name: cannot subtract resources" >&2; return 1; }
    next=$( echo "$next" | non_negative_resources )
    (( $? == 0 )) || { echo "$name: cannot sanitize resources" >&2; return 1; }
    echo "$next" > "$counter"
    return 0
}

# General synchronization function. Takes on input a lock file name to be used
# in a flock call (this file will be truncated to zero) and the command to be
# executed with all the arguments. Example:
#
#     serialize /tmp/mylock myfcn --option1 "$value1" "$arg1" ...
#
# Note: do not re-direct output of the function being protected. Do all writes
# within a function while it is protected by the serialization lock.
function serialize()
{
    local lock=$1
    shift
    (
        flock -x 8
        $@
    ) 8>"$lock"
}

# Lock-protected versions of the relevant functions from this script.
function locked_initialize_resources()
{
    serialize $1 initialize_resources $2 $3
}

function locked_acquire_resources()
{
    serialize $1 acquire_resources $2 $3 $4 $5 $6
}

function locked_release_resources()
{
    serialize $1 release_resources $2 $3
}
