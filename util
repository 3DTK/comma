#!/bin/bash

## @page verify_background_process_ids verify_background_process_ids
# @brief uses pgrep to verify the child processes of a given parent against the expected list
# @param parent the process id of the parent
# @param children arbitrary number of the process ids of the children
function verify_background_process_ids()
{
    local parent=$1
    local children=${@:2}
    children=$( echo "${children// /$'\n'}" | sort -n | tr '\n' ' ' | head -c-1 )
    local named_pids pids
    named_pids=$( pgrep -l -P $parent )
    pids=$( echo "$named_pids" | sort -n -k 1,1 | grep -v pgrep | cut -d' ' -f1 | tr '\n' ' ' | head -c-1 )
    [[ "$children" == "$pids" ]] && return 0
    local process_tree=$( pstree -a -c -g -l -p $parent )
    cat >&2 <<EOF
verify_background_pids: verification failure
    command line:
        '$@'
    parent process:
        '$parent'
    expected children:
        '$children'
    pgrep output:
        '$named_pids'
    extracted pids:
        '$pids'
    process tree:
        '$process_tree'
EOF
    return 1
}
export -f verify_background_process_ids
declare -r verify_background_process_ids

function background_launcher()
{
    local self=$BASHPID
    echo "background_launcher: run in PID '$self'" >&2
    kill -s STOP $self
    # shall be woken up by the caller (and possibly killed at once)
    echo "background_launcher in PID $self: wake up and exec '${@}'" >&2
    exec "${@}"
}
export -f background_launcher
declare -r background_launcher

function wake_up_listed()
{
    local pid stat
    # one possible issue is that verification can finish before background processes
    # even send STOP to themselves; in such a case, they may receive STOP after CONT
    # causing the processes to hang indefinitely
    # therefore, make sure that the process is in stopped state (T) before signalling
    for pid in "$@" ; do
        builtin echo "$FUNCNAME: handle process '$pid'" >&2
        while true ; do
            stat=$( ps --no-headers -o stat --pid $pid ) # calling ps is already a delay; do not sleep
            stat=${stat:0:1} # discard additional BSD characters
            [[ "$stat" == "T" ]] && break
            [[ -z "$stat" ]] && { builtin echo "$FUNCNAME: process '$pid' not found, skip" >&2; break; }
            builtin echo "$FUNCNAME: process '$pid' is not stopped yet, try again" >&2
        done
        [[ "$stat" == "T" ]] && builtin kill -s CONT $pid
    done
    return 0
}
export -f wake_up_listed
declare -r wake_up_listed

function wake_up_dead()
{
    local pid
    for pid in "$@" ; do
        echo "waking up to kill '$pid'" >&2
        kill -s TERM $pid
        kill -s CONT $pid
    done
}
export -f wake_up_dead
declare -r wake_up_dead
