#!/bin/bash

## @page verify_background_process_ids verify_background_process_ids
# @brief uses pgrep to verify the child processes of a given parent against the expected list
# @param parent the process id of the parent
# @param children arbitrary number of the process ids of the children
function verify_background_process_ids()
{
    local parent=$1
    local children=${@:2}
    children=$( echo "${children// /$'\n'}" | sort -n | tr '\n' ' ' | head -c-1 )
    local named_pids pids
    named_pids=$( pgrep -l -P $parent )
    pids=$( echo "$named_pids" | sort -n -k 1,1 | grep -v pgrep | cut -d' ' -f1 | tr '\n' ' ' | head -c-1 )
    [[ "$children" == "$pids" ]] && return 0
    local process_tree=$( pstree -a -c -g -l -p $parent )
    cat >&2 <<EOF
verify_background_pids: verification failure
    command line:
        '$@'
    parent process:
        '$parent'
    expected children:
        '$children'
    pgrep output:
        '$named_pids'
    extracted pids:
        '$pids'
    process tree:
        '$process_tree'
EOF
    return 1
}
export -f verify_background_process_ids
declare -r verify_background_process_ids

function background_launcher()
{
    local self=$BASHPID
    builtin echo "$FUNCNAME: run in PID '$self'" >&2
    builtin kill -s STOP $self
    # shall be woken up by the caller (and possibly killed at once)
    builtin echo "$FUNCNAME: in PID $self: wake up and exec '${@}'" >&2
    exec "${@}"
}
export -f background_launcher
declare -r background_launcher

function wake_up_listed()
{
    local pid stat
    # one possible issue is that verification can finish before background processes
    # even send STOP to themselves; in such a case, they may receive STOP after CONT
    # causing the processes to hang indefinitely
    # therefore, make sure that the process is in stopped state (T) before signalling
    for pid in "$@" ; do
        builtin echo "$FUNCNAME: handle process '$pid'" >&2
        while true ; do
            stat=$( ps --no-headers -o stat --pid $pid ) # calling ps is already a delay; do not sleep
            stat=${stat:0:1} # discard additional BSD characters
            [[ "$stat" == "T" ]] && break
            [[ -z "$stat" ]] && { builtin echo "$FUNCNAME: process '$pid' not found, skip" >&2; break; }
            builtin echo "$FUNCNAME: process '$pid' is not stopped yet, try again" >&2
        done
        [[ "$stat" == "T" ]] && builtin kill -s CONT $pid
    done
    return 0
}
export -f wake_up_listed
declare -r wake_up_listed

function wake_up_and_kill_listed()
{
    local pid
    for pid in "$@" ; do
        builtin echo "$FUNCNAME: handle process '$pid'" >&2
        builtin kill -s TERM $pid
        builtin kill -s CONT $pid
    done
    return 0
}
export -f wake_up_and_kill_listed
declare -r wake_up_and_kill_listed

# function shall be called from the parent process only thus preventing creation of new children dynamically
function wake_up_children()
{
    local parent=$1
    local pids stats
    pids=$( pgrep -P $parent )
    # see wake_up_listed for explanation
    while true ; do
        # this causes some delay, no need to sleep; cut removes additional BSD characters
        stats=$( echo "$pids" | xargs -I{} ps --no-headers -o stat --pid='{}' | sort -u | cut -c1 )
        [[ "$stats" == "T" ]] && break
        [[ -z "$stats" ]] && { builtin echo "$FUNCNAME: no children found for process '$parent', skip" >&2; break; }
        builtin echo "$FUNCNAME: not all children of process '$parent' have stopped, try again" >&2
    done
    [[ "$stats" == "T" ]] || return 0
    pkill --signal=CONT $parent
}
export -f wake_up_children
declare -r wake_up_children

function wake_up_and_kill_children()
{
    local parent=$1
    pkill --signal=TERM $parent
    pkill --signal=CONT $parent
}
export -f wake_up_and_kill_children
declare -r wake_up_and_kill_children
