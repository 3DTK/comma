#!/bin/bash

## @page remove_pgrep_from_its_own_output remove_pgrep_from_its_own_output
# @description 'pgrep -P' call may list the process id of pgrep itself; take on stdin
# the output of pgrep -l -P, filter out the pgrep line, output to stdout the remaining
# process ids as space-separated list
function remove_pgrep_from_its_own_output()
{
    # sort by pid
    # remove the line with pgrep
    # leave only the pid field
    # transform into a single line
    # remove the trailing whitespace
    sort -n -k 1,1 | grep -v pgrep | cut -d' ' -f1 | tr '\n' ' ' | sed 's@ *$@@'
}
export -f remove_pgrep_from_its_own_output
declare -r remove_pgrep_from_its_own_output

## @page report_verify_background_process_error report_verify_background_process_error
# @description auxiliary function provides common error reporting to simplify @link
# verify_background_process_id @endlink and @link verify_background_process_ids @endlink;
# relies on specific variable names used in those functions
# @param arguments command line of the caller, printed verbatim
function report_verify_background_process_error()
{
    local process_tree=$( pstree -a -c -g -l -p $parent )
    cat >&2 <<EOF
verify_background_pids: verification failure
    command line:
        '$1'
    parent process:
        '$parent'
    expected children:
        '$children'
    pgrep output:
        '$named_pids'
    extracted pids:
        '$pids'
    process tree:
        '$process_tree'
EOF
    return 1
}
export -f report_verify_background_process_error
declare -r report_verify_background_process_error

## @page verify_background_process_ids verify_background_process_ids
# @description uses pgrep to verify the child processes of a given parent against the expected list.
# There shall be no other child processes, e.g., created earlier.
# @param parent the process id of the parent
# @param children arbitrary number of the process ids of the children
function verify_background_process_ids()
{
    local parent=$1
    local children=${@:2}
    children=$( echo "${children// /$'\n'}" | sort -n | tr '\n' ' ' | sed 's@ *$@@' )
    local named_pids pids
    named_pids=$( pgrep -l -P $parent )
    pids=$( echo "$named_pids" | remove_pgrep_from_its_own_output )
    [[ "$children" == "$pids" ]] && return 0
    # get here only in case of error
    report_verify_background_process_error "$*"
}
export -f verify_background_process_ids
declare -r verify_background_process_ids

## @page verify_background_process_id verify_background_process_id
# @description uses pgrep to verify that two processes with given PIDs are parent and child
# @param parent the process id of the parent
# @param child the process id of the child
function verify_background_process_id()
{
    local parent=$1
    local child=$2
    local named_pids pids pid
    named_pids=$( pgrep -l -P $parent )
    pids=$( echo "$named_pids" | remove_pgrep_from_its_own_output )
    for pid in $pids ; do
        (( child == pid )) && return 0
    done
    # get here only in case of error
    local children=$child # variable name expected by error-reporter
    report_verify_background_process_error "$*"
}
export -f verify_background_process_id
declare -r verify_background_process_id

function background_launcher()
{
    local self=$BASHPID
    builtin echo "$FUNCNAME: run in PID '$self'" >&2
    builtin kill -s STOP $self
    # shall be woken up by the caller (and possibly killed at once)
    builtin echo "$FUNCNAME: in PID $self: wake up and exec '${@}'" >&2
    exec "${@}"
}
export -f background_launcher
declare -r background_launcher

function wake_up_listed()
{
    local pid stat
    # one possible issue is that verification can finish before background processes
    # even send STOP to themselves; in such a case, they may receive STOP after CONT
    # causing the processes to hang indefinitely
    # therefore, make sure that the process is in stopped state (T) before signalling
    for pid in "$@" ; do
        builtin echo "$FUNCNAME: handle process '$pid'" >&2
        while true ; do
            stat=$( ps --no-headers -o stat --pid $pid ) # calling ps is already a delay; do not sleep
            stat=${stat:0:1} # discard additional BSD characters
            [[ "$stat" == "T" ]] && break
            [[ -z "$stat" ]] && { builtin echo "$FUNCNAME: process '$pid' not found, skip" >&2; break; }
            builtin echo "$FUNCNAME: process '$pid' is not stopped yet, try again" >&2
        done
        [[ "$stat" == "T" ]] && builtin kill -s CONT $pid
    done
    return 0
}
export -f wake_up_listed
declare -r wake_up_listed

function wake_up_and_kill()
{
    local pid=$1
    local rv=0
    builtin echo "$FUNCNAME: handle process '$pid'" >&2
    builtin kill -s TERM $pid || rv=1
    builtin kill -s CONT $pid || rv=1
    return $rv
}
export -f wake_up_and_kill
declare -r wake_up_and_kill

function wake_up_and_kill_listed()
{
    local rv=0
    for pid in "$@" ; do
        wake_up_and_kill $pid
        (( $? == 0 )) || rv=1
    done
    return $rv
}
export -f wake_up_and_kill_listed
declare -r wake_up_and_kill_listed

# function shall be called from the parent process only thus preventing creation of new children dynamically
function wake_up_children()
{
    local parent=$1
    local pids stats
    pids=$( pgrep -P $parent )
    # see wake_up_listed for explanation
    while true ; do
        # this causes some delay, no need to sleep; cut removes additional BSD characters
        stats=$( echo "$pids" | xargs -I{} ps --no-headers -o stat --pid='{}' | sort -u | cut -c1 )
        [[ "$stats" == "T" ]] && break
        [[ -z "$stats" ]] && { builtin echo "$FUNCNAME: no children found for process '$parent', skip" >&2; break; }
        builtin echo "$FUNCNAME: not all children of process '$parent' have stopped, try again" >&2
    done
    [[ "$stats" == "T" ]] || return 0
    pkill --signal=CONT -P $parent
}
export -f wake_up_children
declare -r wake_up_children

function wake_up_and_kill_children()
{
    local parent=$1
    pkill --signal=TERM -P $parent
    pkill --signal=CONT -P $parent
}
export -f wake_up_and_kill_children
declare -r wake_up_and_kill_children
