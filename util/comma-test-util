#!/bin/bash

#   This file is intended to store common and generic  functions used throughout regression tests
#
#   To include these functions and use them in your regression test, use the following command:
#
#   source comma-test-util
#
#   Names are chosen to be short so that they could be used without any overhead (to be discussed, though)

red="\033[0;31m"
green="\033[0;32m"
brown="\033[0;33m"
white="\033[0;37m"
none="\033[m"

status_ok()
{
    [[ ! "${PIPESTATUS[@]}" =~ [1-9] ]]
}
export -f status_ok

#gets the absolute number
function abs()
{
   if [[ $(echo "$1>=0"|bc -l) -eq 1 ]] ; then 	echo $1 ; else echo "$1*-1"|bc ; fi
}

#calculates the value of PI (3.14...)
pi=$(echo "4*a(1)"|bc -l)

#Converts Kelvins to Celsius
function k2c()
{
   echo $1-273.15|bc -l
}

#converts meters to feet
function m2ft()
{
   echo $1/0.3048|bc -l
}

#converts feet to meters
function ft2m()
{
   echo $1*0.3048|bc -l
}

function hypot()
{
   echo "sqrt($1*$1 + $2*$2)"|bc -l
}

#converts meters per second to knots
function ms2kts()
{
   echo "1.94384449 * $1" | bc -l
}

#converts knots to meters per second
function kts2ms()
{
   echo "0.514444444 * $1" | bc -l
}

#converts radians to degrees
function rad2deg()
{
   echo "$1*180/$pi" | bc -l
}

#convert degrees to radians
function deg2rad()
{
   echo "$1 * $pi / 180" | bc -l
}


#compares two numbers, given the epsilon
#returns 1 if their abs difference is less than an epsilon, 0 otherwise
function is_equal()
{
 local  v1=$1
 local  v2=$2
 local  epsilon=$3

 local diff=$(echo $v1 - $v2 | bc -l)

 echo "$(abs $diff) < $epsilon" | bc -l
}



#gets the time in format like: 20130625T090000  and splits it into csv format
function parse_time()
{
   local timestamp=$1

   local year=$(echo $timestamp | cut -c 1-4)
   local month=$(echo $timestamp | cut -c 5-6)
   local day=$(echo $timestamp | cut -c 7-8)
   local hours=$(echo $timestamp | cut -c 10-11)
   local minutes=$(echo $timestamp | cut -c 12-13)
   local seconds=$(echo $timestamp | cut -c 14-15)

   echo $year,$month,$day,$hours,$minutes,$seconds
}

#gets number of seconds from the format like 20130625T090000
function get_utc_seconds()
{
    local current_timestamp=$1
    IFS=, read year month day hours minutes seconds <<< "$(parse_time $current_timestamp)"
    date --utc --date "$year/$month/$day $hours:$minutes:$seconds" +%s
}

#converts utc_seconds since 1970-01-01 (unix-time) to forat like 20130625T090000
function make_time_from_utc_seconds()
{
    date --date "1970-01-01 $1 sec" "+%Y%m%dT%H%M%S"
}


#adds  seconds to the time in the format like  20130625T090000 and outputs in the same format
#eg:  "make_time 20130625T090000  3600"    (adds one 3600 seconds to produces 20130625T100000)
function make_time()
{
   local initial_timestamp=$1
   local add_seconds=$2

   local initial_utc_seconds=$(get_utc_seconds $initial_timestamp)
   make_time_from_utc_seconds $(($initial_utc_seconds+$add_seconds))
}

#gets two timestamps in the format 20130625T090000 and prints out their difference in seconds
function time_diff_seconds()
{
  echo "$(( $(get_utc_seconds $1) - $(get_utc_seconds $2) ))"
}


#output's text in a specific colour (see below), and then restores to default
#eg:   colour_text  red "error: this text goes red"
function colour_text()
{
 local color=$1
 local text=$2

  if [[ "$color" == "red" ]] ; then color_code=1
  elif [[ "$color" == "green" ]] ; then color_code=2
  elif [[ "$color" == "blue" ]] ; then color_code=4
  elif [[ "$color" == "yellow" ]] ; then color_code=3
  elif [[ "$color" == "cyan" ]] ; then color_code=6
  elif [[ "$color" == "magenta" ]] ; then color_code=5
  elif [[ "$color" == "white" ]] ; then color_code=7
  else color_code=7
  fi

  echo -e "$(tput bold)$(tput setaf $color_code)${text}$(tput sgr0)"
}



