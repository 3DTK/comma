#!/bin/bash

# this script is designed to be included in another script directly, for example:
# source $( which comma-util )

[[ -n "$comma_util_include_guard_" ]] && return
readonly comma_util_include_guard_=1

# a coarse elapsed time estimate of <command> execution appended to <file>
# the rationale of writing to a file is to have no side effects for <command>
# usage: comma_elapsed <file> <command> <args>
function comma_elapsed()
{
    local output_file=$1
    local name=$( basename $2 )
    local start=$( date +%s.%N )
    ${@:2}
    local end=$( date +%s.%N )
    local elapsed=$( echo "$end - $start" | bc )
    echo "$name/seconds=$elapsed" >> $output_file
}
export -f comma_elapsed

# append to <file> a coarse progress indication for <command> execution
# the rationale of writing to a file is to have no side effects for <command>
# usage: comma_progress_named <file> <name> <command> <args>
#        where <name> is an arbitrary name of user's choice that will be put in the log
function comma_progress_named()
{
    local output_file=$1
    local name=$2
    echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$name,begin" >> $output_file
    ${@:3}
    local exit_code=$?
    echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$name,end" >> $output_file
    return $exit_code
}
export -f comma_progress_named

# append to <file> a coarse progress indication for <command> execution
# the rationale of writing to a file is to have no side effects for <command>
# usage: comma_progress <file> <command> <args>
function comma_progress()
{
    comma_progress_named $1 $( basename $2 ) ${@:2}
#     local output_file=$1
#     local name=$( basename $2 )
#     echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$name,begin" >> $output_file
#     ${@:2}
#     exit_code=$?
#     echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$name,end" >> $output_file
#     return $exit_code
}
export -f comma_progress

# Auxiliary function: random value uniformly distributed in [0, 1].
function comma_urandom()
{
    echo "$RANDOM / 32767" | bc -l
}
export -f comma_urandom

# This function round-down a scaled random number to an integer.
# Can be used to simulate memory size, number of CPUs, and other
# integer values. Argument is the desired scale: output values
# are from zero to $1.
function comma_round_random()
{
    local scale=$1
    echo "$scale * $( comma_urandom )" | bc | sed 's/^\./0\./;s/\..*//'
}
export -f comma_round_random

# Auxiliary function to convert various storage units to bytes
# Search for regular expressions [0-9]+unit (where space-separation is optional
# and unit is one of kB, MB, GB, and TB) and replaces these substrings with
# corresponding quantities in bytes.
function comma_storage_to_bytes()
{
    local line
    local storage_regex='([0-9]+)( *)([kMGT]B)'
    while true ; do
        read line
        [[ -z "$line" ]] && break
        while true ; do
            # replace storage expressions one-by-one from the left until none found
            if [[ "$line" =~ $storage_regex ]] ; then
                case ${BASH_REMATCH[3]} in
                    kB) value=$(( ${BASH_REMATCH[1]} * 1024 ));;
                    MB) value=$(( ${BASH_REMATCH[1]} * 1024 * 1024 ));;
                    GB) value=$(( ${BASH_REMATCH[1]} * 1024 * 1024 * 1024 ));;
                    TB) value=$(( ${BASH_REMATCH[1]} * 1024 * 1024 * 1024 * 1024 ));;
                esac
                line="${line/${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[3]}/$value}"
            else
                echo "$line"
                break
            fi
        done
    done
}
export -f comma_storage_to_bytes
