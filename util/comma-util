#!/usr/bin/env bash

# this script is designed to be included in another script directly, for example:
# source $( which comma-util )

[[ -n "$comma_util_include_guard_" ]] && return
readonly comma_util_include_guard_=1

# a coarse elapsed time estimate of <command> execution appended to <file>
# the rationale of writing to a file is to have no side effects for <command>
# usage: comma_elapsed <file> <command> <args>
function comma_elapsed()
{
    local output_file=$1
    local name=$( basename $2 )
    local start=$( date +%s.%N )
    ${@:2}
    local end=$( date +%s.%N )
    local elapsed=$( echo "$end - $start" | bc )
    echo "$name/seconds=$elapsed" >> $output_file
}
export -f comma_elapsed

# append to <file> a coarse progress indication for <command> execution
# the rationale of writing to a file is to have no side effects for <command>
# usage: comma_progress_named <file> <name> <command> <args>
#        where <name> is an arbitrary name of user's choice that will be put in the log
function comma_progress_named()
{
    local -r comma_progress_output_file_=$1
    local -r comma_progress_name_=$2
    local -r cmd=$3
    local args=("${@:4}")

    # Remove empty args
    for i in ${!args[@]}; do
        [[ ${args[$i]} = '' ]] && unset args[$i]
    done

    echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$comma_progress_name_,begin" >> $comma_progress_output_file_
    $cmd "${args[@]}"
    local -r exit_code=$?
    echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$comma_progress_name_,end" >> $comma_progress_output_file_
    return $exit_code
}
export -f comma_progress_named

# append to <file> a coarse progress indication for <command> execution
# the rationale of writing to a file is to have no side effects for <command>
# usage: comma_progress <file> <command> <args>
function comma_progress()
{
    comma_progress_named $1 $( basename $2 ) "${@:2}"
#     local output_file=$1
#     local name=$( basename $2 )
#     echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$name,begin" >> $output_file
#     ${@:2}
#     exit_code=$?
#     echo "$( date +%Y%m%dT%H%M%S.%N | cut -b1-22 ),$name,end" >> $output_file
#     return $exit_code
}
export -f comma_progress

# Auxiliary function: random value uniformly distributed in [0, 1].
function comma_urandom()
{
    echo "$RANDOM / 32767" | bc -l
}
export -f comma_urandom

# This function a scaled random number round-down to an integer.
# Can be used to simulate memory size, number of CPUs, and other
# integer values. Argument is the desired scale: output values
# are from zero (inclusive) to $1 (exclusive): [0, $1).
function comma_round_random()
{
    local scale=$1
    local random=$RANDOM
    (( random %= scale ))
    echo $random
}
export -f comma_round_random

# Auxiliary function to convert various storage units to bytes.
# Search for regular expressions [0-9]+unit (where space-separation is optional
# and unit is one of kB, MB, GB, and TB) and replaces these substrings with
# corresponding quantities in bytes.
function comma_storage_to_bytes()
{
    local line
    local storage_regex='([0-9]+)( *)([kMGT]B)'
    while true ; do
        read line
        [[ -z "$line" ]] && break
        while true ; do
            # replace storage expressions one-by-one from the left until none found
            if [[ "$line" =~ $storage_regex ]] ; then
                case ${BASH_REMATCH[3]} in
                    kB) value=$(( ${BASH_REMATCH[1]} * 1024 ));;
                    MB) value=$(( ${BASH_REMATCH[1]} * 1024 * 1024 ));;
                    GB) value=$(( ${BASH_REMATCH[1]} * 1024 * 1024 * 1024 ));;
                    TB) value=$(( ${BASH_REMATCH[1]} * 1024 * 1024 * 1024 * 1024 ));;
                esac
                line="${line/${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[3]}/$value}"
            else
                echo "$line"
                break
            fi
        done
    done
}
export -f comma_storage_to_bytes

# Auxiliary function opposite to comma_storage_to_bytes.
# Round-trip conversion to-from-bytes (or from-to) does not produce identical output.
function comma_storage_to_human_readable()
{
    local line path value suffix
    local numeric_regex='^[0-9]+$'
    while read line ; do
        [[ $line != *memory* ]] && { echo "$line"; continue; }
        suffix=""
        value=${line#*=}
        if [[ "$value" =~ $numeric_regex ]] ; then
            (( value > 10 * 1024 )) && { value=$(( value / 1024 )); suffix=" kB"; }
            (( value > 10 * 1024 )) && { value=$(( value / 1024 )); suffix=" MB"; }
            (( value > 10 * 1024 )) && { value=$(( value / 1024 )); suffix=" GB"; }
            path=${line%%=*}
            echo "$path=${value}${suffix}"
        else
            echo "$line"
        fi
    done
}
export -f comma_storage_to_human_readable
