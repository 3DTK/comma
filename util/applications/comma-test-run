#!/bin/bash

# This file is part of comma, a generic and flexible library
# Copyright (c) 2011 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

name=$( basename $0 )

source $( which comma-application-util ) || { echo "$name: cannot source 'comma-application-util'" >&2; exit 1; }
source $( which comma-random-util ) || { echo "$name: cannot source 'comma-random-util'" >&2; exit 1; }
source $( which comma-units-util ) || { echo "$name: cannot source 'comma-units-util'" >&2; exit 1; }
source $( which comma-resources-util ) || { echo "$name: cannot source 'comma-resources-util'" >&2; exit 1; }
source $( which comma-progress-util ) || { echo "$name: cannot source 'comma-progress-util'" >&2; exit 1; }
source $( which comma-sync-util ) || { echo "$name: cannot source 'comma-sync-util'" >&2; exit 1; }
source $( which comma-env-util ) || { echo "$name: cannot source 'comma-env-util'" >&2; exit 1; }
source $( which comma-string-util ) || { echo "$name: cannot source 'comma-string-util'" >&2; exit 1; }
source $( which comma-process-util ) || { echo "$name: cannot source 'comma-process-util'" >&2; exit 1; }

name_offset="${name//?/ } "
export name name_offset

# determine system parameters and set defaults; command-line options operate in MB
comma_path_value_to_var --prefix=max < <( comma_total_system_resources )
max_resources_memory_main=$(( $max_resources_memory_main / 1024 / 1024 ))
max_resources_memory_shared=$(( $max_resources_memory_shared / 1024 / 1024 ))
data_storage=""
max_parallel=$max_resources_cpus
max_memory_main=$max_resources_memory_main
max_memory_shared=$max_resources_memory_shared
max_wait_time="forever"
max_run_time="3600"

red="\033[0;31m"
green="\033[0;32m"
brown="\033[0;33m"
white="\033[0;37m"
none="\033[m"

function default_options()
{
    cat <<EOF
path=$data_storage
parallel=0
quiet=0
debug=0
until_first_failure=0
max_parallel=$max_parallel
max_memory_main=$max_memory_main
max_memory_shared=$max_memory_shared
max_wait_time=$max_wait_time
max_run_time=$max_run_time
raw=0
EOF
}

function description()
{
    cat <<EOF
--help,-h; show this help, --help --verbose for more help
--black-list=[<file>]; do not run these tests mentioned in <file>, e.g. a lists of sub-directories in white list to be excluded. Format - see --white-list below.
--debug; much more debug output
--end=[<dir>]; run tests up to a given test, the latter excluded, where test directories are ordered lexicographically
--from,--begin=[<dir>]; run tests starting from a given test, where test directories are ordered lexicographically
--junit; output to stdout junit record compatible with jenkins for each test
--max-parallel=[<N>]; run up to N tests in parallel; default: $max_parallel
--max-memory-main=[<N>]; limit on main memory, in MB; default: $max_memory_main
--max-memory-shared=[<N>]; limit on shared memory, in MB; default: $max_memory_shared
--max-wait-time=[<time>]; maximal time to wait for available CPUs before failing a test, default: ${max_wait_time}
--max-run-time=[<time>]; maximal time to wait for a test completion before failing it by force, default: ${max_run_time}
--no-ansiterm-control-characters,--no-control-characters,--raw; unstyled output (no ANSIterm control characters)
--output-directories,--dry-run,--dry; output list of test directories intended to run and exit
--path=[<dir>]; data-storage directory for tests, default: none, let the tests define it
--parallel; run tests in parallel
--quiet,-q; minimize output
--run-disabled; run disabled tests
--run-optional,--optional; run tests having file called "optional" (same logic as for --run-disabled)
--stdin; read paths from stdin e.g. run test in hello/world: echo hello/world | comma-test-run --stdin
--test-option=[<option>]; extra command line argument(s) pass to "test" script
--to=[<dir>]; run tests up to a given test, the latter included, where test directories are ordered lexicographically
--until-first-failure; exit after the first failure (works only when tests run serially)
--verbose,-v; more output
--white-list=[<file>]; only run these tests mentioned in the <file>, applied first before black list. Comment lines starting with # ignored. Each entry in the list matches to sub directory or directories name using pattern ^<subdir>; see examples.
--estimate-resources; in serial mode, accumulates performance data using comma-top into 'output/performance.csv' files; note: file may be empty for very short tests
EOF
}

function usage_()
{
echo -e "

Search for and execute tests under the current directory.

Find subdirectories containing the files ${brown}test${none}, ${brown}input${none}, or ${brown}expected${none}. Execute 'test', then either:
    (a) if 'expected' exists, compare its contents to the output of 'test' ("path=value" format)
    (b) otherwise the success of the test depends on the exit status of the 'test' script.

Return 0 if all tests succeed, or non-zero if any of the tests fail.
Output of the test scripts is recorded in ${brown}output/stderr.log${none} and ${brown}output/stdout.log${brown}.

Usage: comma-test-run [<options>]

${brown}A quick tutorial${none}

    mkdir success
    echo "hello=\"world\"" > success/input
    echo "hello=\"world\"" > success/expected
    echo "cat" > success/test
    chmod +x success/test

    comma-test-run

    mkdir failure
    echo "hello=\"world\"" > failure/input
    echo "hello=\"moon\"" > failure/expected
    echo "cat" > failure/test
    chmod +x failure/test

    comma-test-run

${brown}Options:${none}
$( description | sed 's/^/    /g' )

"

[[ -n "$1" ]] || { echo -e "${brown}For more help use: comma-test-run --help --verbose${none}\\n" ; exit 0 ; }

echo -e "

${brown}Input, test, output, and expected files${none}
    File 'input', if exists, is fed to the stdin of the test script.

    If there is an 'input' or 'expected' file but no 'test' in the same directory, the 'test' script in the
    closest parent directory is used. If there is a 'test' by itself with no 'input' or 'expected' file,
    it is only executed if there is no subdirectory containing 'input', 'expected' or 'test'.

    Test output will be put into the subdirectory 'output'. This will contain standard error log 'output/stderr.log'
    and output log 'output/stdout.log'. The contents of 'output/stdout.log' is matched to the 'expected' file.

${brown}Disabling tests${none}
    to disable tests in a directory and all its subdirectories
    create an empty file named ${brown}disabled${none} in that directory

${brown}Optional tests${none}
    you may not want to run some tests by default (e.g. stress tests, very long tests, etc)
    to make tests optional in a directory and all its subdirectories
    create an empty file named ${brown}optional${none} in that directory

${brown}Reading test directories from stdin${none}
    convenient for test filtering and reordering, e.g:
        comma-test-run --dry-run | grep 'some/topic' | comma-test-run --stdin

${brown}Running tests in parallel${none}
    (a) If none of '--parallel' and '--max-parallel' options is given, tests are run sequentially.
    (b) If '--max-parallel' is given, e.g., as in '--max-parallel=4', up to 4 tests are run at once;
        but see below for load-balancing.
    (c) If '--parallel' is given without '--max-parallel', the script attempts to use as many CPUs/cores
        as are available on the system. This is ${red}not recommended${none} for resource-heavy tests
        unless additional configuration files are provided as explained below.

${brown}Load-balancing and serializing tests${none}
    to describe a resourse-heavy test, create a file named ${brown}config${none} in the test directory
    and specify the number of CPUs and the amount of shared memory to be used by the test;
    may also specify 'serial=\"true\"' to serialize the test.

    Examples of config files:

        resources/cpus=4
        resources/memory/shared=3200 MB

    Will not run until at least 4 or all CPUs (out of '--max-parallel' number) are available. Will
    not run until 3200 MB of shared memory (counted out of '--max-memory-shared' total) is available.

        resources/serial=\"true\"

    Will run only when no other test is running.

    The required memory sizes can be specified in units of kB, MB, or GB. However, the value must
    be an integer, i.e., values like 3.2 GB are not allowed and have to be approximated as 3300 MB.

    When running multiple tests, will wait at most for the period specified by '--max-wait-time' seconds
    until the resources are available. If the wait time exceeds the limit, will fail the test.

    No test shall take longer than the period specified by '--max-run-time'. If a test does not complete
    within this time, it is forcefully terminated and marked as failed.

${brown}White(and black)-listing tests${none}
    The test names in the white/black list file shall match ${brown}exactly${none} the corresponding
    names in '--dry-run' output, e.g.
        comma-test-run --dry-run
            ./input/test1
            ./input/test2
            ./output/test1
    then
        echo "./input/test2" > white.list
        comma-test-run --white-list=white.list
    Do not remove leading dots or append input file names or anything similar.

${brown}White(and black)-listing pro hint${none}
    Assume some tests failed:
        comma-test-run > comma-test-run.log 2>&1 ; echo $?
        1
    Create a white list from log file:
        grep run comma-test-run.log | grep failed | sed 's@.*run: @@;s@:.*@@' > white.list
    Fix something and re-run only the failed tests:
        comma-test-run --white-list=white.list
"
    exit 0
}

function error_()
{
    if [[ "$options_no_ansiterm_control_characters" == "1" ]] ; then
        echo -e "$1" >&2
    else
        tput bold
        local high="\033[1;31m"
        local normal="\033[0m"
        echo -e "$high$1$normal" >&2
        tput sgr0
    fi
}
export -f error_

function message_()
{
    [[ "$options_quiet" != "1" ]] || return
    if [[ "$options_no_ansiterm_control_characters" == "1" ]] ; then
        echo $1 >&2
    else
        tput bold
        echo $1 >&2
        tput sgr0
    fi
}
export -f message_

function dump_file_()
{
    if [[ "$options_quiet" != "1" ]] ; then cat "$1" >&2 ; fi
}
export -f dump_file_

function warning_()
{
    [[ "$options_quiet" != "1" ]] || return
    if [[ "$options_no_ansiterm_control_characters" == "1" ]] ; then
        echo -e "$1" >&2
    else
        local high="\033[1;33m"
        local normal="\033[0m"
        echo -e "$high$1$normal" >&2
    fi
}
export -f warning_

function disabled_()
{
    local filename=$1   # "disabled" or "optional"
    local dir=$2
    local force=$3
    local verbose=$4
    if [[ "$force" == "1" ]]; then return 1; fi
    if [[ -f "$dir/$filename" ]] ; then
        if [[ "$verbose" == "--verbose" ]]; then
            if [[ -s $dir/$filename ]] ; then warning_ "$name: test $counter: $dir: $filename:" ; cat $dir/$filename | sed 's/^/    /' >&2
            else error_ "$name: test $counter: $dir: $filename (with no explanation)" ; fi
        fi
        return 0
    fi
    local d=$( dirname $dir )
    if [[ "$d" == "$dir" ]] ; then return 1 ; fi
    disabled_ "$filename" "$d" "$force" "$verbose"
    return $?
}
export -f disabled_

# copy input to output, and return failure (1) if there was any output
function fail_on_output()
{
    if grep "."; then return 1; else return 0; fi
}
export -f fail_on_output

# arguments: a list of directories containing "test", "input" and "expected" files
# Outputs the same list, excluding any directories that
# (1) contain only "test" (no "expected" or "input" file), and
# (2) have at least one subdirectory containing another test, OR where "test" itself is a directory
# This is so that it is possible to have a generic "test" script in the base directory that is not
# executed in that directory.
function exclude_generic_tests()
{
    local dir_list=$*
    local result_list=()

    for dir in $dir_list; do
        if [[ ! -f "$dir/input" && ! -f "$dir/expected" && ! -f "$dir/disabled" ]]; then
            if [[ -d "$dir/test" ]]; then continue; fi
            if [[ -f "$dir/test" ]]; then
                local pattern="^$( comma_escape_special_chars "$dir" )/."
                if echo $dir_list | fmt -1 | grep -q "$pattern"; then
                    if [[ "$options_debug" != "0" ]] ; then echo "excluding generic test '$dir/test'" >&2; fi
                    continue
                fi
            fi
        fi
        result_list+=( $dir )
    done

    echo "${result_list[@]}" | tr ' ' '\n'
}

# find "test" file inside a path, checking in each subdirectory (starting from the full path)
# arguments: <path> <file to find>
function closest_test_in_path()
{
    local path=$1
    local file="test"

    # sanity check (and avoid infinite loop)
    if [[ -z "$path" ]]; then echo "$name: error: empty path in closest_file_in_path()" >&2; exit 1; fi
    # get canonical name (so path always starts with "/")
    path=$( readlink -e "$path" )

    while true; do
        if [[ -d "$path/$file" ]]; then
            echo "$name: warning: \"$path/$file\" is a directory (expected an executable script); ignoring" >&2
        elif [[ -f "$path/$file" ]]; then
            if [[ -x "$path/$file" ]]; then echo $path/$file; break
            else echo "$name: warning: \"$path/$file\" is not executable; ignoring" >&2; fi
        elif [[ $path == "/" ]]; then break
        fi
        path=$( dirname "$path" )
    done
}
export -f closest_test_in_path

# "dirname" with multiple arguments allowed (since some versions of "dirname" don't allow them)
function get_dirnames()
{
    local i
    for i in $@; do dirname "$i" ; done
}

function stats_init()
{
    stats="$( pwd )/stats"
    stats_progress_csv="$stats/progress.csv"
    stats_elapsed_path_value="$stats/elapsed.csv"
    rm -rf "$stats" || return 1
    mkdir "$stats" || return 1
    touch "$stats_progress_csv"
}

function junit_finalize() # quick and dirty
{
    echo "<testsuite tests=\"$( cat $stats_elapsed_path_value | wc -l )\">"
    cat $stats_elapsed_path_value \
        | while IFS='=' read key elapsed ; do
              path="$( dirname $key )"
              local attributes="classname=\"testcase\" name=\"$( echo $path | sed "s#^\./##" )\" time=\"$elapsed\""
              if [[ -f $path/output/failure ]] ; then
                  echo "    <testcase $attributes >"
                  echo "        <failure>"
                  cat $path/output/failure | recode ascii..html
                  echo "        </failure>"
                  echo "    </testcase>"
              else
                  echo "    <testcase $attributes />"
              fi
           done
      echo "</testsuite>"
}

function stats_finalize()
{
    [[ -f "$stats_progress_csv" ]] || return
    cat "$stats_progress_csv" | comma-progress --elapsed > "$stats_elapsed_path_value"
    [[ -z "$options_junit" ]] || junit_finalize
}

function resources_limits()
{
    # the "serial" Boolean is used numerically: false as 0, true as 1, then 1 > 0, etc.
    # the limit of "true" (1) means only 1 task at a time can be serial (occupy this
    # resource to itself)
    cat <<EOF
resources/cpus=$max_parallel
resources/memory/main=$max_memory_main
resources/memory/shared=$max_memory_shared
resources/serial="true"
EOF
}
export -f resources_limits

# initially no resources are occupied
function comma_test_run_initialize_resources()
{
    comma_test_run_resources_flock="$comma_test_run_unique_dir/resources_flock"
    comma_test_run_resources_counter="$comma_test_run_unique_dir/resources_counter.json"
    comma_test_run_resources_limits="$comma_test_run_unique_dir/resources_limits.json"
    resources_limits | name-value-convert --from path-value --to json > "$comma_test_run_resources_limits"
    touch "$comma_test_run_resources_flock"
    resources_limits | comma_locked "$comma_test_run_resources_flock" comma_initialize_resources "$comma_test_run_resources_counter"
    export comma_test_run_resources_flock comma_test_run_resources_counter comma_test_run_resources_limits
}

# used to initialize variables to non-empty values
function default_requirements()
{
    cat <<EOF
resources/cpus=1
resources/memory/main=0
resources/memory/shared=0
resources/serial="false"
EOF
}
export -f default_requirements

function get_required_resources()
{
    ( default_requirements; [[ -f ./config ]] && cat ./config; ) | comma_path_value_take_last | name-value-convert --from path-value --to json
}
export -f get_required_resources

function report_waiting()
{
    local msg=$1
    [[ "$options_debug" != "0" ]] && {
        [[ "$first" == "true" ]] && {
            echo -n "$name_offset $msg ." >&2
            first="false"
        } || {
            echo -n " ." >&2
        }
    }
}
export -f report_waiting

function report_end_of_wait() {
    [[ "$first" == "false" && "$options_debug" != "0" ]] && echo " end of wait" >&2
    first="true"
}
export -f report_end_of_wait

# auxiliary function to simplify setting the same handler for multiple signals
# _and_ telling the handler which signal has been intercepted
function setup_signal_handler()
{
    local handler=$1
    trap "$handler SIGINT" SIGINT
    trap "$handler SIGTERM" SIGTERM
    trap "$handler SIGHUP" SIGHUP
    trap "$handler SIGPIPE" SIGPIPE
}
export -f setup_signal_handler

function comma_top_wrapper()
{
    trap - SIGINT SIGTERM SIGHUP SIGPIPE  # default handler
    local log=$1
    comma-top --sampling-interval=0.5 > "$log"
}
export -f comma_top_wrapper

# this functions terminates a currently running test using its group id
# the test running under the timeout command will have its own group id
function terminate_run_and_match_test()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "$name: terminating test in $( pwd )..." >&2
    if [[ -n "$comma_test_run_and_match_test_pgid" ]] ; then
        kill -s TERM -- -$comma_test_run_and_match_test_pgid
        wait $comma_test_run_and_match_test_pgid
        comma_wait_for_process_group "$name" "$comma_test_run_and_match_test_pgid" 12
        unset comma_test_run_and_match_test_pgid
    fi
    if [[ -n "$comma_top_pgid" ]] ; then
        kill -s TERM -- -$comma_top_pgid
        wait $comma_top_pgid
        comma_wait_for_process_group "$name" "$comma_top_pgid" 12
        unset comma_top_pgid
    fi
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -SIGINT $BASHPID ; }
    exit 1
}
export -f terminate_run_and_match_test

# this functions executes a provided test with optional input and captures its stdout
# then it optionally compares the output with the expected file
# finally echoes the result of comma-test-match and the status of the match
function run_and_match_test()
{
    local test_output test_failed match_output error_files

    rm -rf output || exit 1
    mkdir -p output || exit 1

    test_output=$( if [ -f ./input ] ; then cat ./input ; fi \
        | comma_progress_named "$our_stats_progress" "$dir" comma_env --default "$test_exec" "$path" "$verbose" $options_test_option 2>"output/stderr.log" )
    test_failed=$?
    error_files="$( find . -name out_of_shared_memory )"
    [[ -n "$error_files" ]] && return 1

    echo "$test_output" > "output/stdout.log"

    if [[ $test_failed != 0 ]]; then echo "test exit with non-zero status: $test_failed" >&2; fi

    if [[ $test_failed == 0 && -f "./expected" ]]; then
        match_output=$( echo "$test_output" | comma-test-match ./expected 2>&1 )
        if [[ -n "$match_output" ]]; then
            error_ "$name: test output does not match expected:\n"
            echo "expected output:" >&2
            echo "$match_output" >&2
            echo >&2
            test_failed=1
        fi
    fi

    if [[ -n "$options_junit" ]] ; then
        rm -rf output/failure
        [[ $test_failed == 0 ]] || echo "$match_output" > output/failure
    fi

    return $test_failed
}
export -f run_and_match_test

# this function runs a provided test application under the timeout command
function run_test_with_timeout()
{
    setup_signal_handler terminate_run_and_match_test
    export -f comma_progress_named
    export our_stats_progress dir test_exec path verbose
    if [[ "$options_estimate_resources" == "1" ]] ; then
        local our_performance_log="$comma_test_run_unique_dir/performance_log.$( mktemp --dry-run XXXXXX )"
        timeout -k 10 -s TERM $max_run_time bash -c comma_top_wrapper\ "$our_performance_log" & comma_top_pgid=$!
    fi
    # Note: timeout option '-k' is missing in RHEL6, remove '-k 10' if need be
    local rv
    timeout -k 10 -s TERM $max_run_time bash -c run_and_match_test & comma_test_run_and_match_test_pgid=$!
    wait $comma_test_run_and_match_test_pgid
    rv=$?
    comma_wait_for_process_group "$name" "$comma_test_run_and_match_test_pgid" 12
    unset comma_test_run_and_match_test_pgid
    if [[ "$options_estimate_resources" == "1" ]] ; then
        kill -s TERM -- -$comma_top_pgid
        wait $comma_top_pgid
        comma_wait_for_process_group "$name" "$comma_top_pgid" 12
        unset comma_top_pgid
        mv -f "$our_performance_log" "output/performance.csv"
    fi
    return $rv
}
export -f run_test_with_timeout

function terminate_run_single_test()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "$name: single test run terminated by $1..." >&2
    if [[ -n "$comma_test_run_test_pid" ]] ; then
        kill -s TERM -- $comma_test_run_test_pid
        wait $comma_test_run_test_pid
        unset comma_test_run_test_pid
    fi
    # serialize all access to global resources: stats file, stdout/err
    (
        flock -x 9
        cat "$our_stderrout_log" >&3
        local msg="test $count in '$dir': killed"
        echo "$msg" >&9
    ) 9>>"$comma_test_run_output_flock"

    rm -f "$our_stats_progress"
    rm -f "$our_stderrout_log"
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -s INT $BASHPID ; }
    exit 1
}
export -f terminate_run_single_test

# Auxiliary function to make waiting for resource a one-liner
function random_sleep()
{
    local max_nap=$1
    local sleep_time=$( echo $RANDOM | gawk -v max_nap=$max_nap '{ print $1 * $max_nap / 32768 }' )
    wait_time=$( echo $wait_time $sleep_time | gawk '{ print $1 + $2 }' )
    sleep ${sleep_time}s & comma_test_run_test_pid=$!
    wait $comma_test_run_test_pid
    unset comma_test_run_test_pid
}
export -f random_sleep

# this function runs the actual test; must be run as a background process
# arguments:
#     path to q-storage       - where the data are
#     stats file name         - will write start/stop time into this file
#     verbosity flag          - auxiliary, chatter more/less
#     total                   - total number of tests
#     count                   - sequential test number
#     test directory          - will cd and run the test inside
function run_single_test()
{
    local path=$1
    [[ -n "$path" ]] && path="--path=$path"
    local stats_progress=$2
    local verbose=$3
    local total=$4
    local count=$5
    local dir=$6
    # unquote, just in case
    local temp="${dir%\"}"
    dir="${temp#\"}"
    local worker_id=$BASHPID

    setup_signal_handler terminate_run_single_test

    local counter="$count of $total"

    # create a unique file for local comma_progress output; will append to the main output at the end
    local our_stats_progress="$comma_test_run_unique_dir/stats_progress.$( mktemp --dry-run XXXXXX )"
    >"$our_stats_progress"

    # say something so that the user is not guessing what is going on
    (
        flock -x 9
        message_ "$name: test $counter: $dir: started..."
    ) 9>>"$comma_test_run_output_flock"
    # if running tests in parallel, create a unique file for redirecting all output
    # will append to the main output at the end
    local our_stderrout_log="$comma_test_run_unique_dir/stdout_log.$( mktemp --dry-run XXXXXX )"
    # todo? or output junit <testcase> tags as we go, but that would require refactoring of this function:
    #       instead of equilibristics with stderr redirection, test output should have various output modes,
    #       e.g: text, csv, junit, etc
    if [[ -z "$options_junit" ]] ; then exec 3>&1 4>&2 1>"$our_stderrout_log" 2>&1 ; else exec 3>&1 4>&2 1>"$our_stderrout_log" ; fi

    # must save pid of any background process in this variable, so that it is killed by signal handler
    local comma_test_run_test_pid

    local test_exec basedir outcome
    local result=0
    local request="$comma_test_run_unique_dir/request.${worker_id}.json"

    if disabled_ "disabled" "$dir" "$options_run_disabled" --verbose; then
        :   # message already printed
    elif disabled_ "optional" "$dir" "$options_run_optional" ; then
        warning_ "$name: test $counter: $dir: optional, skipped"
    else
        test_exec=$( closest_test_in_path "$dir" )
        if [[ -z "$test_exec" ]]; then
            error_ "$name: error: no \"test\" script found in any parent directory of $dir" >&2
            result=1
        else
            message_ "$name: test $counter: $dir: running..."

            basedir=$( pwd )

            ## Comment out for now: the exact usage to be discussed, it is confusing and can be taken as a sign of error
            ##[ -f "$dir/readme" ] && dump_file_ "$dir/readme"
            cd "$dir"
            local wait_time=0
            get_required_resources | comma_storage_to_bytes > "$request"
            local first="true"
            while true ; do
                outcome=$( comma_locked "$comma_test_run_resources_flock" comma_acquire_resources "$request" "$comma_test_run_resources_counter" "$comma_test_run_resources_limits" "$worker_id" )
                if [[ $? == 0 ]] ; then
                    report_end_of_wait
                    local error_files test_failed
                    find . -name out_of_shared_memory | xargs rm -f
                    # run this test on the background under a separate group id provided by the timeout command
                    # wait for the period of max_run_time, and, if still running, kill the group and fail the test
                    run_test_with_timeout & comma_test_run_test_pid=$!
                    wait $comma_test_run_test_pid
                    test_failed=$?
                    unset comma_test_run_test_pid
                    comma_locked "$comma_test_run_resources_flock" comma_release_resources "$request" "$comma_test_run_resources_counter" "$worker_id"
                    (( $? == 0 )) || {
                        error_ "$name: test $counter: $dir: failed on release_resources, request '$( cat $request )'"
                        result=1
                        break
                    }
                    error_files="$( find . -name out_of_shared_memory )"
                    [[ -n "$error_files" ]] && {
                        report_waiting "ran out of shared memory, re-try"
                        echo "$error_files" | xargs rm -f
                        continue
                    }
                    [[ "$test_failed" == "0" ]] && {
                        message_ "$name: test $counter: $dir: succeeded"
                    } || {
                        result=1
                        error_ "$name: $dir: failed$( (( $test_failed == 124 )) && echo ' (likely timed out)' )"
                    }
                    break
                else
                    if [[ "$outcome" == "wait" ]] ; then
                        report_waiting "waiting for resources"
                        [[ "$max_wait_time" != "forever" ]] && {
                            if gawk '{ a=$1 > $2; exit !a }' < <( echo $wait_time $max_wait_time ) ; then
                                echo "$name: in '$dir', could not get requested resources for ${wait_time}s, failed to run" >&2
                                result=1
                                break
                            fi
                        }
                        random_sleep 2 # make a configuration parameter
                        continue
                    else
                        error_ "$name: test $counter: $dir: failed on acquire_resources, outcome '$outcome', request '$( cat $request )'"
                        result=1
                        break
                    fi
                fi
            done
            cd $basedir
        fi
    fi

    # serialize all access to global resources: stats file, stdout/err
    (
        flock -x 9
        cat "$our_stats_progress" >> "$stats_progress"
        cat "$our_stderrout_log" >&3
        local msg="test $count in '$dir': "
        (( $result == 0 )) && { msg+="success"; } || { msg+="failed"; }
        echo "$msg" >&9
    ) 9>>"$comma_test_run_output_flock"

    rm -f "$our_stats_progress"
    rm -f "$our_stderrout_log"

    return $result
}
export -f run_single_test

function terminate_tests_parallel()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "$name: parallel test run terminated by $1..." >&2
    if [[ -n "$comma_test_run_xargs_pid" ]] ; then
        kill -s STOP -- $comma_test_run_xargs_pid
        pkill --signal TERM -P $comma_test_run_xargs_pid
        kill -s TERM -- $comma_test_run_xargs_pid
        kill -s CONT -- $comma_test_run_xargs_pid
        wait $comma_test_run_xargs_pid
        unset comma_test_run_xargs_pid
    fi
    rm -f "$comma_test_run_xargs_pipe"
    is_killed=true
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -s INT $BASHPID ; }
    exit 1
}

function process_tests_parallel()
{
    setup_signal_handler terminate_tests_parallel
    comma_test_run_xargs_pipe="$comma_test_run_unique_dir/xargs.pipe"
    mkfifo -m 600 "$comma_test_run_xargs_pipe"
    xargs -P $max_parallel -I{} bash -c run_single_test\ "'$options_path'"\ "'$stats_progress_csv'"\ "'$verbose'"\ "'$test_scripts_count'"\ {} < "$comma_test_run_xargs_pipe" & comma_test_run_xargs_pid=$!
    xargs -n2 > "$comma_test_run_xargs_pipe"
    wait $comma_test_run_xargs_pid
    (( $? != 0 )) && result=1
    unset comma_test_run_xargs_pid
    rm -f "$comma_test_run_xargs_pipe"
    unset comma_test_run_xargs_pipe
}

function terminate_tests_serial()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "$name: serial test run terminated by $1..." >&2
    if [[ -n "$comma_test_run_single_test_pid" ]] ; then
        kill -s TERM -- $comma_test_run_single_test_pid 2>/dev/null
        wait $comma_test_run_single_test_pid
        unset comma_test_run_single_test_pid
    fi
    is_killed=true
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -s INT $BASHPID ; }
    exit 1
}

function process_tests_serial()
{
    setup_signal_handler terminate_tests_serial
    local line rv
    while true; do
        read line
        [[ -z "$line" ]] && break
        run_single_test "$options_path" "$stats_progress_csv" "$verbose" "$test_scripts_count" $line & comma_test_run_single_test_pid=$!
        wait $comma_test_run_single_test_pid
        rv=$?
        unset comma_test_run_single_test_pid
        (( $rv == 0 )) || {
            result=1
            [[ "$options_until_first_failure" == "1" ]] && return 1
        }
    done
    return 0
}

function count_failures()
{
    (
        flock -x 9
        grep -c "\<failed\>" "$comma_test_run_output_flock"
    ) 9>>"$comma_test_run_output_flock"
}
export -f count_failures

function clean_working_dir() { [[ -n "$comma_test_run_unique_dir" ]] && rm -fr "$comma_test_run_unique_dir" ; }

function final_words()
{
    local failed_count=$( count_failures )
    local afterword=
    [[ "$is_killed" == "true" ]] && afterword=" (before killed)"
    if [[ "$failed_count" == 0 ]] ; then message_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): succeeded${afterword}" ; else error_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): $failed_count test[s] out of $test_scripts_count failed${afterword}" ; fi
    [[ "$options_debug" != "0" && -n "$comma_test_run_output_flock" ]] && { echo "$name: detailed breakdown:" >&2 ; cat "$comma_test_run_output_flock" >&2; }
}

# process command line...
if (( $( comma_options_has --help $@ ) || $( comma_options_has -h $@ ) )) ; then
    if (( $( comma_options_has --verbose $@ ) || $( comma_options_has -v $@ ) )) ; then usage_ --verbose ; else usage_ ; fi
fi
comma_path_value_to_var  --prefix=options < <( default_options )
comma_path_value_to_var --prefix=options < <( description | comma-options-to-name-value $@ )

# and perform sanity check
[[ -n "$options_path" && ! -d "$options_path" ]] && { error_ "$name: directory '$options_path' not found"; exit 1; }
have_max_parallel=$( comma_options_has --max-parallel=$options_max_parallel $@ )
(( $options_parallel == 0 && $have_max_parallel == 0 )) && options_max_parallel=1
(( $have_max_parallel != 0 )) && options_parallel=1
(( $options_max_parallel < 1 )) && { error_ "$name: number of parallel tests $options_max_parallel < 1"; exit 1; }
(( $options_max_memory_main < 1 )) && { error_ "$name: amount of shared memory $options_max_memory_main < 1 MB"; exit 1; }
(( $options_max_memory_shared < 1 )) && { error_ "$name: amount of shared memory $options_max_memory_shared < 1 MB"; exit 1; }
[[ "$options_max_wait_time" != "forever" ]] && {
    (( $options_max_wait_time < 1 )) && { error_ "$name: wait time $options_max_wait_time < 1s or not a number"; exit 1; }
}
(( $options_max_run_time < 1 )) && { error_ "$name: timeout run time $options_max_run_time < 1s or not a number"; exit 1; }
[[ "$options_parallel" != "0" && "$options_estimate_resources" == "1" ]] && { error_ "$name: resource estimation shall be serial"; exit 1; }
if [[ "$options_debug" != "0" ]] ; then verbose="--verbose" ; fi
(( options_verbose )) && verbose="--verbose"

# and convert to bytes and export for everyone to use
max_parallel=$options_max_parallel
max_memory_main=$(( $options_max_memory_main * 1024 * 1024 ))
max_memory_shared=$(( $options_max_memory_shared * 1024 * 1024 ))
max_wait_time=$options_max_wait_time
max_run_time=$options_max_run_time
export max_parallel max_memory_main max_memory_shared max_wait_time max_run_time options_debug options_quiet options_path options_until_first_failure options_test_option options_parallel options_no_ansiterm_control_characters options_run_disabled options_run_optional options_junit options_estimate_resources

function apply_white_list()
{
    if [[ -n "$options_white_list" ]] ; then grep -E "$options_white_list"; else cat ; fi
}
function apply_black_list()
{
    if [[ -n "$options_black_list" ]] ; then grep -vE "$options_black_list"; else cat ; fi
}
function apply_white_black_list()
{
    apply_white_list | apply_black_list
}

# to run, search for directories containing either "test", "input" or "expected";
# if "test" is absent, use the "test" in the closest parent directory
function test_directories()
{
    if [[ -n "$options_white_list" && -f "$options_white_list" ]]; then
        message_ "$name: applying white list from file '$options_white_list'">&2
        options_white_list="^(\./)?($( sed 's#\./##' <$options_white_list | grep -v ^# | grep -v ^$ | tr \\n '|' | sed 's/|$//'  ))";
    fi
    if [[ -n "$options_black_list" && -f "$options_black_list" ]]; then
        message_ "$name: applying black list from file '$options_black_list'">&2
        options_black_list="^(\./)?($( sed 's#\./##' <$options_black_list | grep -v ^# | grep -v ^$ | tr \\n '|' | sed 's/|$//' ))";
    fi

    test_script_dirs_all=( $( exclude_generic_tests $( get_dirnames $( find . -name "test" -or -name "input" -or -name "expected" | grep -v "/\." ) 2>/dev/null | sort -u ) | apply_white_black_list ) )
    [[ -n "$options_from" || -n "$options_to" || -n "$options_end" ]] || { echo ${test_script_dirs_all[@]} ; return ; }
    [[ -z "$options_from" ]] || { local from="${options_from#\.\/}" ; }
    [[ -z "$options_to" ]] || { local to="${options_to#\.\/}" ; }
    [[ -z "$options_end" ]] || { local end="${options_end#\.\/}" ; }
    for d in ${test_script_dirs_all[@]} ; do
        local e="${d#\.\/}"
        [[ -z "$from" || "$e" == "$from" ]] || continue
        unset from
        [[ -z "$end" || "$e" != "$end" ]] || return
        echo $d
        [[ -z "$to" || "$e" != "$to" ]] || return
    done
}

if [[ -z "$options_stdin" ]] ; then
    test_script_dirs=( $( test_directories ) )
else
    while read line ; do
        [[ -d "$line" ]] || { echo "$name: directory not found: \"$line\"" >&2 ; exit 1 ; }
        test_script_dirs+=( "$line" )
    done
fi
[[ -z "$options_output_directories" ]] || { echo ${test_script_dirs[@]} | tr ' ' '\n' ; exit 0 ; }
test_scripts_count=${#test_script_dirs[@]}

export comma_test_run_unique_dir=
export comma_test_run_output_flock=
trap 'stats_finalize; final_words; clean_working_dir' EXIT
stats_init || { error_ "$name: could not initialize stats"; exit 1; }

# keep all plumbing under a common directory
temp_dir=$( readlink -e "stats" )
comma_test_run_unique_dir=$( mktemp --directory --tmpdir="$temp_dir" comma-test-run.XXXXXX ) || { error_ "$name: cannot create unique working directory"; exit 1; }
export comma_test_run_unique_dir
# to run tests in parallel, we need to lock stats_progress_csv and/or stdout/stderr
# this is the global flock name
comma_test_run_output_flock="$comma_test_run_unique_dir/output_flock"
export comma_test_run_output_flock

# store the currently occupied resources (number of CPUs, amount of memory)
# in a global file name; access serialized via flocks
comma_test_run_initialize_resources

result=0
run_tests="process_tests_parallel"
[[ "$options_parallel" == "0" ]] && run_tests="process_tests_serial"

count=0
if (( $test_scripts_count > 0 )) ; then
    message_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): running..."
    $run_tests < <( for dir in ${test_script_dirs[@]} ; do
        (( ++count ))
        echo "$count  \"$dir\""
    done )
else
    echo -e "${brown}$name: warning: no tests found in $( pwd )${none}" >&2
fi

exit $result
