#!/bin/bash

name=$( basename $0 )

source $( which comma-application-util ) || { echo "$name: cannot source 'comma-application-util'" >&2; exit 1; }
source $( which comma-util ) || { echo "$name: cannot source 'comma-util'" >&2; exit 1; }
source $( which comma-resources-util ) || { echo "$name: cannot source 'comma-resources-util'" >&2; exit 1; }
source $( which comma-sync ) || { echo "$name: cannot source 'comma-sync'" >&2; exit 1; }

name_offset="${name//?/ } "
export name name_offset

# determine system parameters and set defaults; command-line options operate in MB
comma_path_value_to_var --prefix=max < <( comma_total_system_resources )
max_resources_memory_main=$(( $max_resources_memory_main / 1024 / 1024 ))
max_resources_memory_shared=$(( $max_resources_memory_shared / 1024 / 1024 ))
data_storage=""
max_parallel=$max_resources_cpus
max_memory_main=$max_resources_memory_main
max_memory_shared=$max_resources_memory_shared
max_wait_time="forever"
max_run_time="3600"

red="\033[0;31m"
green="\033[0;32m"
brown="\033[0;33m"
white="\033[0;37m"
none="\033[m"

function default_options()
{
    cat <<EOF
path=$data_storage
parallel=0
quiet=0
debug=0
until_first_failure=0
force=0
max_parallel=$max_parallel
max_memory_main=$max_memory_main
max_memory_shared=$max_memory_shared
max_wait_time=$max_wait_time
max_run_time=$max_run_time
raw=0
EOF
}

function description()
{
    cat <<EOF
--help,-h; show this help
--debug; much more debug output
--end=[<dir>]; run tests up to a given test, the latter excluded, where test directories are ordered lexicographically
--force,-f; include disabled tests
--from,--begin=[<dir>]; run tests starting from a given test, where test directories are ordered lexicographically
--max-parallel=[<N>]; run up to N tests in parallel; default: $max_parallel
--max-memory-main=[<N>]; limit on main memory, in MB; default: $max_memory_main
--max-memory-shared=[<N>]; limit on shared memory, in MB; default: $max_memory_shared
--max-wait-time=[<time>]; maximal time to wait for available CPUs before failing a test, default: ${max_wait_time}
--max-run-time=[<time>]; maximal time to wait for a test completion before failing it by force, default: ${max_run_time}
--output-directories,--dry-run,--dry; output list of test directories intended to run and exit
--path=[<dir>]; data-storage directory for tests, default: none, let the tests define it
--parallel; run tests in parallel
--quiet,-q; minimize output
--test-option=[<option>]; extra command line argument(s) pass to "test" script
--to=[<dir>]; run tests up to a given test, the latter included, where test directories are ordered lexicographically
--until-first-failure; exit after the first failure (works only when tests run serially)
--no-ansiterm-control-characters,--no-control-characters,--raw; unstyled output (no ANSIterm control characters)
--white-list=[<file>]; only run these tests mentioned in the <file>, this is applied first before black list. Comment lines starting with # are ignored. Each entry in the list matches to sub directory or directories name using pattern ^<subdir>   
--black-list=[<file>]; do not run these tests mentioned in <file>, e.g. a lists of sub-directories in white list to be excluded. Format - see --white-list above.
EOF
}

# put into a separate function to avoid using echo -e on each line
function raw_usage_()
{
    cat <<EOF

Searches for and executes tests under the current directory.

Usage: comma-test-run [<options>]

Find subdirectories containing the files ${brown}test${none}, ${brown}input${none} or ${brown}expected${none}. Execute 'test', then either:
    (a) if 'expected' exists, compare its contents to the output of 'test' ("path=value" format)
    (b) otherwise the success of the test depends on the exit status of the 'test' script.

    
A quick tutorial

    mkdir success
    echo "hello=\"world\"" > success/input
    echo "hello=\"world\"" > success/expected
    echo "cat" > success/test
    chmod +x success/test

    comma-test-run

    mkdir failure
    echo "hello=\"world\"" > failure/input
    echo "hello=\"moon\"" > failure/expected
    echo "cat" > failure/test
    chmod +x failure/test

    comma-test-run

    
File 'input', if exists, is fed to the stdin of the test script.

If there is an 'input' or 'expected' file but no 'test' in the same directory, the 'test' script in the
closest parent directory is used. If there is a 'test' by itself with no 'input' or 'expected' file,
it is only executed if there is no subdirectory containing 'input', 'expected' or 'test'.

Returns 0 if all tests succeed, or non-zero if any of the tests fail.

Options:
$( description | sed 's/^/    /g' )

Disabling tests:
    to disable tests in a directory and all its subdirectories
    create an empty file named ${brown}disabled${none} in that directory

Running tests in parallel:
    (a) If none of '--parallel' and '--max-parallel' options is given, tests are run sequentially.
    (b) If '--max-parallel' is given, e.g., as in '--max-parallel=4', up to 4 tests are run at once;
        but see below for load-balancing.
    (c) If '--parallel' is given without '--max-parallel', the script attempts to use as many CPUs/cores
        as are available on the system. This is ${red}not recommended${none} for resource-heavy tests
        unless additional configuration files are provided as explained below.

Load-balancing and serializing tests:
    to describe a resourse-heavy test, create a file named ${brown}config${none} in the test directory
    and specify the number of CPUs and the amount of shared memory to be used by the test;
    may also specify 'serial="true"' to serialize the test.

    Examples of config files:

        resources/cpus=4
        resources/memory/shared=3200 MB

    Will not run until at least 4 or all CPUs (out of '--max-parallel' number) are available. Will
    not run until 3200 MB of shared memory (counted out of '--max-memory-shared' total) is available.

        resources/serial="true"

    Will run only when no other test is running.

    The required memory sizes can be specified in units of kB, MB, or GB. However, the value must
    be an integer, i.e., values like 3.2 GB are not allowed and have to be approximated as 3300 MB.

    When running multiple tests, will wait at most for the period specified by '--max-wait-time' seconds
    until the resources are available. If the wait time exceeds the limit, will fail the test.

    No test shall take longer than the period specified by '--max-run-time'. If a test does not complete
    within this time, it is forcefully terminated and marked as failed.

EOF
}

function usage_() { echo -e "$( raw_usage_ )\n" >&2 ; exit 1 ; }

function error_()
{
    if [[ "$options_no_ansiterm_control_characters" == "1" ]] ; then
        echo -e "$1" >&2
    else
        tput bold
        high="\033[1;31m"
        normal="\033[0m"
        echo -e "$high$1$normal" >&2
        tput sgr0
    fi
}
export -f error_

function message_()
{
    [[ "$options_quiet" != "1" ]] || return
    if [[ "$options_no_ansiterm_control_characters" == "1" ]] ; then
        echo $1 >&2
    else
        tput bold
        echo $1 >&2
        tput sgr0
    fi
}
export -f message_

function dump_file_()
{
    if [[ "$options_quiet" != "1" ]] ; then cat "$1" >&2 ; fi
}
export -f dump_file_

function warning_()
{
    [[ "$options_quiet" != "1" ]] || return
    if [[ "$options_no_ansiterm_control_characters" == "1" ]] ; then
        echo -e "$1" >&2
    else
        tput bold
        echo -e "${brown}$1${none}" >&2
        tput sgr0
    fi
}
export -f warning_

function disabled_()
{
    if [[ "$options_force" == "1" ]]; then return 1; fi
    if [[ -f "$1/disabled" ]] ; then return 0 ; fi
    d=$( dirname $1 )
    if [[ "$d" == "$1" ]] ; then return 1 ; fi
    disabled_ $d
    return $?
}
export -f disabled_

# copy input to output, and return failure (1) if there was any output
function fail_on_output()
{
    if grep "."; then return 1; else return 0; fi
}
export -f fail_on_output

# return a string with "\" before any characters that are special in regular expressions
function escape_special_chars()
{
    echo $* | sed 's/[].*|&^$[]/\\&/g'
}

# arguments: a list of directories containing "test", "input" and "expected" files
# Outputs the same list, excluding any directories that
# (1) contain only "test" (no "expected" or "input" file), and
# (2) have at least one subdirectory containing another test, OR where "test" itself is a directory
# This is so that it is possible to have a generic "test" script in the base directory that is not
# executed in that directory.
function exclude_generic_tests()
{
    local dir_list=$*
    local result_list=()

    for dir in $dir_list; do
        if [[ ! -f "$dir/input" && ! -f "$dir/expected" && ! -f "$dir/disabled" ]]; then
            if [[ -d "$dir/test" ]]; then continue; fi
            if [[ -f "$dir/test" ]]; then
                local pattern="^$( escape_special_chars "$dir" )/."
                if echo $dir_list | fmt -1 | grep -q "$pattern"; then
                    if [[ "$options_debug" != "0" ]] ; then echo "Excluding generic test '$dir/test'" >&2; fi
                    continue
                fi
            fi
        fi
        result_list+=( $dir )
    done

    echo "${result_list[@]}"
}

# find "test" file inside a path, checking in each subdirectory (starting from the full path)
# arguments: <path> <file to find>
function closest_test_in_path()
{
    local path=$1
    local file="test"

    # sanity check (and avoid infinite loop)
    if [[ -z "$path" ]]; then echo "$name: error: empty path in closest_file_in_path()" >&2; exit 1; fi
    # get canonical name (so path always starts with "/")
    path=$( readlink -e "$path" )

    while true; do
        if [[ -d "$path/$file" ]]; then
            echo "$name: warning: \"$path/$file\" is a directory (expected an executable script); ignoring" >&2
        elif [[ -f "$path/$file" ]]; then
            if [[ -x "$path/$file" ]]; then echo $path/$file; break
            else echo "$name: warning: \"$path/$file\" is not executable; ignoring" >&2; fi
        elif [[ $path == "/" ]]; then break
        fi
        path=$( dirname "$path" )
    done
}
export -f closest_test_in_path

# "dirname" with multiple arguments allowed (since some versions of "dirname" don't allow them)
function get_dirnames()
{
    for i in $*; do dirname $i; done
}

function stats_init()
{
    stats="$(pwd)/stats"
    stats_progress_csv="$stats/progress.csv"
    stats_elapsed_path_value="$stats/elapsed.csv"
    rm -rf $stats
    mkdir $stats
    touch "$stats_progress_csv"
}

function stats_finalize()
{
    if [[ -f $stats_progress_csv ]] ; then cat $stats_progress_csv | comma-progress --elapsed > $stats_elapsed_path_value ; fi
}

function resources_limits()
{
    # the "serial" Boolean is used numerically: false as 0, true as 1, then 1 > 0, etc.
    # the limit of "true" (1) means only 1 task at a time can be serial (occupy this
    # resource to itself)
    cat <<EOF
resources/cpus=$max_parallel
resources/memory/main=$max_memory_main
resources/memory/shared=$max_memory_shared
resources/serial="true"
EOF
}
export -f resources_limits

# initially no resources are occupied
function comma_test_run_initialize_resources()
{
    comma_test_run_resources_flock="$comma_test_run_unique_dir/resources_flock"
    comma_test_run_resources_counter="$comma_test_run_unique_dir/resources_counter.json"
    comma_test_run_resources_limits="$comma_test_run_unique_dir/resources_limits.json"
    resources_limits | name-value-convert --from path-value --to json > "$comma_test_run_resources_limits"
    touch "$comma_test_run_resources_flock"
    resources_limits | comma_locked "$comma_test_run_resources_flock" comma_initialize_resources "$comma_test_run_resources_counter"
    export comma_test_run_resources_flock comma_test_run_resources_counter comma_test_run_resources_limits
}

# used to initialize variables to non-empty values
function default_requirements()
{
    cat <<EOF
resources/cpus=1
resources/memory/main=0
resources/memory/shared=0
resources/serial="false"
EOF
}
export -f default_requirements

function get_required_resources()
{
    ( default_requirements; [[ -f ./config ]] && cat ./config; ) | name-value-convert --from path-value --to json
}
export -f get_required_resources

function report_waiting()
{
    local msg=$1
    [[ "$options_debug" != "0" ]] && {
        [[ "$first" == "true" ]] && {
            echo -n "$name_offset $msg ." >&2
            first="false"
        } || {
            echo -n " ." >&2
        }
    }
}
export -f report_waiting

function report_end_of_wait() {
    [[ "$first" == "false" && "$options_debug" != "0" ]] && echo " end of wait" >&2
    first="true"
}
export -f report_end_of_wait

# auxiliary function to simplify setting the same handler for multiple signals
# _and_ telling the handler which signal has been intercepted
function setup_signal_handler()
{
    local handler=$1
    trap "$handler SIGINT" SIGINT
    trap "$handler SIGTERM" SIGTERM
    trap "$handler SIGHUP" SIGHUP
    trap "$handler SIGPIPE" SIGPIPE
}
export -f setup_signal_handler

# this functions terminates a currently running test using its group id
# the test running under the timeout command will have its own group id
function terminate_run_and_match_test()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "terminating test in $( pwd )..." >&2
    if [[ -n "$test_pgid" ]] ; then
        kill -s TERM -- -$test_pgid 2>/dev/null
        wait $test_pgid
    fi
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -SIGINT $BASHPID ; }
    exit 1
}
export -f terminate_run_and_match_test

# this functions executes a provided test with optional input and captures its stdout
# then it optionally compares the output with the expected file
# finally echoes the result of comma-test-match and the status of the match
function run_and_match_test()
{
    local test_output test_failed match_output error_files
    test_output=$( if [ -f ./input ] ; then cat ./input ; fi \
        | comma_progress_named "$our_stats_progress" "$dir" "$test_exec" "$path" "$verbose" $options_test_option )
    test_failed=$?
    error_files="$( find . -name out_of_shared_memory )"
    [[ -n "$error_files" ]] && return 1
    if [[ $test_failed == 1 && -n "$test_output" ]]; then
        echo "test exit with non-zero status, output '$test_output'" >&2
    fi
    if [[ $test_failed == 0 && -f "./expected" ]]; then
        match_output=$( echo "$test_output" | comma-test-match ./expected 2>&1 )
        if [[ -n "$match_output" ]]; then
            echo "$match_output" >&2
            test_failed=1
        fi
    fi
    return $test_failed
}
export -f run_and_match_test

# this function runs a provided test application under the timeout command
function run_test_with_timeout()
{
    setup_signal_handler terminate_run_and_match_test
    export -f comma_progress_named
    export our_stats_progress dir test_exec path verbose
    # Note: timeout option '-k' is missing in RHEL6, remove '-k 10' if need be
    local test_pgid
    timeout -k 10 -s TERM $max_run_time bash -c run_and_match_test & test_pgid=$!
    wait $test_pgid
    local rv=$?
    unset test_pgid
    return $rv
}
export -f run_test_with_timeout

function terminate_run_single_test()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "test run terminated by $1..." >&2
    if [[ -n "$test_pid" ]] ; then
        kill -s TERM -- $test_pid 2>/dev/null
        wait $test_pid
    fi
    # serialize all access to global resources: stats file, stdout/err
    (
        flock -x 9
        [[ "$options_parallel" == "0" ]] || cat "$our_stdout_log" >&3
        local msg="test $count in '$dir': killed"
        echo "$msg" >&9
    ) 9>>"$comma_test_run_output_flock"

    rm -f "$our_stats_progress"
    [[ "$options_parallel" == "0" ]] || rm -f "$our_stdout_log"
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -s INT $BASHPID ; }
    exit 1
}
export -f terminate_run_single_test

# Auxiliary function to make waiting for resource a one-liner
function random_sleep()
{
    local max_nap=$1
    local sleep_time=$( echo $RANDOM | awk -v max_nap=$max_nap '{ print $1 * $max_nap / 32768 }' )
    wait_time=$( echo $wait_time $sleep_time | awk '{ print $1 + $2 }' )
    sleep ${sleep_time}s &
    test_pid=$!
    wait $test_pid
}
export -f random_sleep

# this function runs the actual test; must be run as a background process
# arguments:
#     path to q-storage       - where the data are
#     stats file name         - will write start/stop time into this file
#     verbosity flag          - auxiliary, chatter more/less
#     total                   - total number of tests
#     count                   - sequential test number
#     test directory          - will cd and run the test inside
function run_single_test()
{
    local path=$1
    [[ -n "$path" ]] && path="--path=$path"
    local stats_progress=$2
    local verbose=$3
    local total=$4
    local count=$5
    local dir=$6
    # unquote, just in case
    local temp="${dir%\"}"
    dir="${temp#\"}"
    local worker_id=$BASHPID

    setup_signal_handler terminate_run_single_test

    local counter="$count of $total"

    # create a unique file for local comma_progress output; will append to the main output at the end
    local our_stats_progress="$comma_test_run_unique_dir/stats_progress.$(mktemp -u XXXXXX)"
    >"$our_stats_progress"

    # if running tests in parallel, create a unique file for redirecting all output
    # will append to the main output at the end
    [[ "$options_parallel" == "0" ]] || {
        local our_stdout_log="$comma_test_run_unique_dir/stdout_log.$( mktemp -u XXXXXX )"
        exec 3>&1 4>&2 1>"$our_stdout_log" 2>&1
    }

    local test_exec basedir
    # must save pid of any background process in this variable, so that it is killed by signal handler
    local test_pid outcome
    local result=0
    local request="$comma_test_run_unique_dir/request.${worker_id}.json"

    if disabled_ "$dir" ; then
        warning_ "$name: test $counter: $dir: disabled"
    else
        test_exec=$( closest_test_in_path "$dir" )
        if [[ -z "$test_exec" ]]; then
            error_ "$name: error: no \"test\" script found in any parent directory of $dir" >&2
            result=1
        else
            message_ "$name: test $counter: $dir: running..."

            basedir=$( pwd )

            ## Comment out for now: the exact usage to be discussed, it is confusing and can be taken as a sign of error
            ##[ -f "$dir/readme" ] && dump_file_ "$dir/readme"
            cd "$dir"
            local wait_time=0
            get_required_resources | comma_storage_to_bytes > "$request"
            local first="true"
            while true ; do
                outcome=$( comma_locked "$comma_test_run_resources_flock" comma_acquire_resources "$request" "$comma_test_run_resources_counter" "$comma_test_run_resources_limits" "$worker_id" )
                if [[ $? == 0 ]] ; then
                    report_end_of_wait
                    local error_files test_failed
                    find . -name out_of_shared_memory | xargs rm -f
                    # run this test on the background under a separate group id provided by the timeout command
                    # wait for the period of max_run_time, and, if still running, kill the group and fail the test
                    run_test_with_timeout & test_pid=$!
                    wait $test_pid
                    test_failed=$?
                    comma_locked "$comma_test_run_resources_flock" comma_release_resources "$request" "$comma_test_run_resources_counter" "$worker_id"
                    (( $? == 0 )) || {
                        echo "$name::worker $worker_id: cannot release resources" >&2
                        result=1
                        break
                    }
                    error_files="$( find . -name out_of_shared_memory )"
                    [[ -n "$error_files" ]] && {
                        report_waiting "ran out of shared memory, re-try"
                        echo "$error_files" | xargs rm -f
                        continue
                    }
                    [[ "$test_failed" == "0" ]] && {
                        message_ "$name: test $counter: $dir: succeeded"
                    } || {
                        result=1
                        error_ "$name: $dir: failed$( (( $test_failed == 124 )) && echo ' (likely timed out)' )"
                    }
                    break
                else
                    if [[ "$outcome" == "wait" ]] ; then
                        report_waiting "waiting for resources"
                        [[ "$max_wait_time" != "forever" ]] && {
                            if awk '{ a=$1 > $2; exit !a }' < <( echo $wait_time $max_wait_time ) ; then
                                echo "$name: in '$dir', could not get $parallel CPUs for ${wait_time}s, failed to run" >&2
                                result=1
                                break
                            fi
                        }
                        random_sleep 2 # make a configuration parameter
                        continue
                    else
                        echo "$name::worker $worker_id: unknown error in comma_acquire_resources '$outcome'" >&2
                        result=1
                        break
                    fi
                fi
            done
            cd $basedir
        fi
    fi

    # serialize all access to global resources: stats file, stdout/err
    (
        flock -x 9
        cat "$our_stats_progress" >> "$stats_progress"
        [[ "$options_parallel" == "0" ]] || cat "$our_stdout_log" >&3
        local msg="test $count in '$dir': "
        (( $result == 0 )) && { msg+="success"; } || { msg+="failed"; }
        echo "$msg" >&9
    ) 9>>"$comma_test_run_output_flock"

    rm -f "$our_stats_progress"
    [[ "$options_parallel" == "0" ]] || rm -f "$our_stdout_log"

    return $result
}
export -f run_single_test

function terminate_tests_parallel()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "parallel test run terminated by $1..." >&2
    if [[ -n "$xargs_pid" ]] ; then
        kill -s STOP -- $xargs_pid 2>/dev/null
        pkill --signal TERM -P $xargs_pid 2>/dev/null
        kill -s TERM -- $xargs_pid 2>/dev/null
        kill -s CONT -- $xargs_pid 2>/dev/null
        wait $xargs_pid
    fi
    rm -f "$comma_test_run_xargs_pipe"
    is_killed=true
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -s INT $BASHPID ; }
    exit 1
}

function process_tests_parallel()
{
    setup_signal_handler terminate_tests_parallel
    comma_test_run_xargs_pipe="$comma_test_run_unique_dir/xargs.pipe"
    mkfifo -m 600 "$comma_test_run_xargs_pipe"
    local xargs_pid
    xargs -P $max_parallel -I{} bash -c run_single_test\ "'$options_path'"\ "'$stats_progress_csv'"\ "'$verbose'"\ "'$test_scripts_count'"\ {} < "$comma_test_run_xargs_pipe" & xargs_pid=$!
    xargs -n2 > "$comma_test_run_xargs_pipe"
    wait "$xargs_pid"
    (( $? != 0 )) && result=1
    rm -f "$comma_test_run_xargs_pipe"
    unset comma_test_run_xargs_pipe
}

function terminate_tests_serial()
{
    trap '' SIGINT SIGTERM SIGHUP SIGPIPE
    echo "serial test run terminated by $1..." >&2
    if [[ -n "$test_pid" ]] ; then
        kill -s TERM -- $test_pid 2>/dev/null
        wait $test_pid
    fi
    is_killed=true
    # a process that exits in response to SIGINT should kill itself with SIGINT
    # see http://www.cons.org/cracauer/sigint.html
    [[ "$1" == "SIGINT" ]] && { trap - INT ; kill -s INT $BASHPID ; }
    exit 1
}

function process_tests_serial()
{
    setup_signal_handler terminate_tests_serial
    local test_pid line
    while true; do
        read line
        [[ -z "$line" ]] && break
        run_single_test "$options_path" "$stats_progress_csv" "$verbose" "$test_scripts_count" $line &
        test_pid=$!
        wait $test_pid
        (( $? == 0 )) || {
            result=1
            [[ "$options_until_first_failure" == "1" ]] && return 1
        }
    done
    return 0
}

function count_failures()
{
    (
        flock -x 9
        grep -c "failed" "$comma_test_run_output_flock"
    ) 9>>"$comma_test_run_output_flock"
}
export -f count_failures

function final_words()
{
    failed_count=$( count_failures )
    local afterword=
    [[ "$is_killed" == "true" ]] && afterword=" (before killed)"
    if [[ "$failed_count" == 0 ]] ; then message_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): succeeded${afterword}" ; else error_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): $failed_count test[s] out of $test_scripts_count failed${afterword}" ; fi
    [[ "$options_debug" != "0" ]] && { echo "$name: detailed breakdown:" >&2 ; cat "$comma_test_run_output_flock" >&2; }
    rm -fr "$comma_test_run_unique_dir"
}

# process command line...
if (( $( comma_options_has --help $@ ) || $( comma_options_has -h $@ ) )) ; then usage_ ; fi
comma_path_value_to_var  --prefix=options < <( default_options )
comma_path_value_to_var --prefix=options < <( description | comma-options-to-name-value $@ )
# and perform sanity check
[[ -n "$options_path" && ! -d "$options_path" ]] && { error_ "$name: directory '$options_path' not found"; exit 1; }
have_max_parallel=$( comma_options_has --max-parallel=$options_max_parallel $@ )
(( $options_parallel == 0 && $have_max_parallel == 0 )) && options_max_parallel=1
(( $have_max_parallel != 0 )) && options_parallel=1
(( $options_max_parallel < 1 )) && { error_ "$name: number of parallel tests $options_max_parallel < 1"; exit 1; }
(( $options_max_memory_main < 1 )) && { error_ "$name: amount of shared memory $options_max_memory_main < 1 MB"; exit 1; }
(( $options_max_memory_shared < 1 )) && { error_ "$name: amount of shared memory $options_max_memory_shared < 1 MB"; exit 1; }
[[ "$options_max_wait_time" != "forever" ]] && {
    (( $options_max_wait_time < 1 )) && { error_ "$name: wait time $options_max_wait_time < 1s or not a number"; exit 1; }
}
(( $options_max_run_time < 1 )) && { error_ "$name: timeout run time $options_max_run_time < 1s or not a number"; exit 1; }
# and convert to bytes and export for everyone to use
max_parallel=$options_max_parallel
max_memory_main=$(( $options_max_memory_main * 1024 * 1024 ))
max_memory_shared=$(( $options_max_memory_shared * 1024 * 1024 ))
max_wait_time=$options_max_wait_time
max_run_time=$options_max_run_time
export max_parallel max_memory_main max_memory_shared max_wait_time max_run_time options_debug options_quiet options_path options_until_first_failure options_test_option options_parallel options_no_ansiterm_control_characters

# keep all plumbing under a common directory
temp_dir=$( dirname "$( mktemp -d -u )" )
comma_test_run_unique_dir=$( mktemp -d --tmpdir="$temp_dir" comma-test-run.XXXXXX )
export comma_test_run_unique_dir
# to run tests in parallel, we need to lock stats_progress_csv and/or stdout/stderr
# this is the global flock name
comma_test_run_output_flock="$comma_test_run_unique_dir/output_flock"
export comma_test_run_output_flock

# store the currently occupied resources (number of CPUs, amount of memory)
# in a global file name; access serialized via flocks
comma_test_run_initialize_resources

trap 'stats_finalize; final_words' EXIT

basedir=$( pwd )
result=0

stats_init

function apply_white_list()
{
    if [[ -n "$options_white_list" ]] ; then grep -E "$options_white_list"; else cat ; fi
}
function apply_black_list()
{
    if [[ -n "$options_black_list" ]] ; then grep -vE "$options_black_list"; else cat ; fi
}
function apply_white_black_list()
{
    apply_white_list | apply_black_list
}

# to run, search for directories containing either "test", "input" or "expected";
# if "test" is absent, use the "test" in the closest parent directory
function test_directories()
{
    if [[ -n "$options_white_list" && -f "$options_white_list" ]]; then 
        echo "$name: applying white list from file '$options_white_list'">&2
        options_white_list="^(\./)?($( sed 's#\./##' <$options_white_list | grep -v ^# | tr \\n '|' | sed 's/|$//'  ))"; 
    fi
    if [[ -n "$options_black_list" && -f "$options_black_list" ]]; then 
        echo "$name: applying black list from file '$options_black_list'">&2
        options_black_list="^(\./)?($( sed 's#\./##' <$options_black_list | grep -v ^# | tr \\n '|' | sed 's/|$//' ))"; 
    fi

    test_script_dirs_all=( $( exclude_generic_tests $( get_dirnames $( find . -name "test" -or -name "input" -or -name "expected" | grep -v "/\." ) 2> /dev/null | sort -u  | apply_white_black_list ) ) )
    [[ -n "$options_from" || -n "$options_to" || -n "$options_end" ]] || { echo ${test_script_dirs_all[@]} ; return ; }
    [[ -z "$options_from" ]] || { local from="${options_from#\.\/}" ; }
    [[ -z "$options_to" ]] || { local to="${options_to#\.\/}" ; }
    [[ -z "$options_end" ]] || { local end="${options_end#\.\/}" ; }
    for d in ${test_script_dirs_all[@]} ; do
        local e="${d#\.\/}"
        [[ -z "$from" || "$e" == "$from" ]] || continue
        unset from
        [[ -z "$end" || "$e" != "$end" ]] || return
        echo $d
        [[ -z "$to" || "$e" != "$to" ]] || return
    done
}

test_script_dirs=( $( test_directories ) )
[[ -z "$options_output_directories" ]] || { trap "" EXIT ; echo ${test_script_dirs[@]} | tr ' ' '\n' ; exit ; }
test_scripts_count=${#test_script_dirs[@]}
count=0
failed_count=0
if [[ "$options_debug" != "0" ]] ; then verbose="--verbose" ; fi

run_tests="process_tests_parallel"
[[ "$options_parallel" == "0" ]] && run_tests="process_tests_serial"

if (( $test_scripts_count > 0 )) ; then
    message_ "$name: $test_scripts_count test[s] in subdirectories of $( pwd ): running..."
    $run_tests < <( for dir in ${test_script_dirs[@]} ; do
        (( ++count ))
        echo "$count  \"$dir\""
    done )
else
    echo -e "${brown}$name: warning: no tests found in $( pwd )${none}" >&2
fi

exit $result
