#!/bin/bash

basename=$( basename $0 )

function usage
{
    cat >&2 <<EOF

Usage: $basename [options]

Generate graphviz visualisation of profile data

Options:

    --strict-size: size the nodes strictly
    --scale-edges: scale edges rather than nodes

    If --strict-size is not used then the nodes will size to the minimum
    of their ideal size and the size required to contain the text.
    In other words they'll sometimes be too large.

Examples:

    The output can most usefully be piped into dot.

    cat elapsed.path_value | $basename | dot -Tsvg > profile.svg
    cat elapsed.path_value | $basename --strict-size | dot -Tsvg > profile.svg
    cat elapsed.path_value | $basename --scale-edges | dot -Tsvg > profile.svg

EOF
    exit
}

function bye()
{
    [[ -f $input_tmp ]] && rm $input_tmp
}

trap bye EXIT

scaled_object=node

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        --scale-edges)
            scaled_object=edge
            ;;
        --strict-size)
            strict_size=1
            ;;
        -*)
            echo "$name: unrecognized option '$1'" >&2
            exit 1
            ;;
    esac
    shift
done

function nodename { echo $1 | tr '.-' '_'; }

input_tmp=$( mktemp input.tmp.XXXXXX ) || {
    echo "failed to create temp dir $update_file_fields_tmp" >&2
    exit 1
}

cat - > $input_tmp

declare -A sums

# This slightly cryptic setting of "sums" is because piped commands run in sub-shells
# so if we did "cat ... | comma... | sed ... | while ..." the variable wouldn't be
# set it the main shell.
#
# We also can't do: sums=( $( cat / comma / sed ) ) because only a literal can be
# inside the parentheses. You could use "eval", but you probably don't want to do that.

while read line; do
    key=$( echo $line | cut -f1 -d= )
    value=$( echo $line | cut -f2 -d= )
    # Put the value from comma-progress in the same format as the original -
    # three decimal places and no trailing 0's
    sums[$key]=$( printf "%0.3f" $value | sed -r 's/(\.[0-9]*[1-9])0*$/\1/' )
done < <( cat $input_tmp | comma-progress --sum \
             | sed -r -e 's#^#/#' -e "s#^.*/(.*)/elapsed=\"(.*)\"#\1=\2#" )

nodes_done=""

# fixedsize=shape should keep the circle at the proscribed size but use the
# larger of the circle and the text for determining layout.
# However it doesn't seem to actually work so we'll use "false" instead
# unless told otherwise.
fixedsize_option=false
[[ $strict_size ]] && fixedsize_option=true

echo "digraph callgraph {"

cat $input_tmp | while read line || [[ -n $line ]]; do
    elapsed=$( echo $line | cut -f2 -d= | sed 's/"//g' )
    pair=$( echo $line | sed "s!/elapsed=.*!!" | rev | cut -f1,2 -d/ | rev )
    target=$( echo $pair | cut -f2 -d/ )

    # If sums doesn't exist: value=elapsed
    # If sums exists and is the same as elapsed: value=elapsed
    # If sums exists and is different to elapsed: value=sums and show elapsed on edge
    value=$elapsed
    unset show_elapsed
    if [[ ${sums[$target]} ]]; then
        (( $( echo "${sums[$target]} == $elapsed" | bc ) )) || {
            value=${sums[$target]}
            show_elapsed=1
        }
    fi

    size=$( echo "sqrt( $value )" | sed 's/e/ * 10^/g' | bc )
    [[ $target == "run_all" ]] && size=1
    fontsize=$( echo "$size * 10" | bc )
    node_value_label="${value}s"
    edge_value_label="${value}s"
    [[ $show_elapsed ]] && edge_value_label="${elapsed}s"

    if ! echo $nodes_done | grep -q "\b$target\b"; then
        [[ $scaled_object == "node" ]] && node_size_field="fixedsize=$fixedsize_option width=$size fontsize=$fontsize"
        echo -e "\t$( nodename $target ) [label=\"$target\n($node_value_label)\" shape=circle $node_size_field ]"
        nodes_done+=" $target"
    fi

    if echo $pair | grep -q '/'; then
        relationship=$( nodename $pair | sed 's!/! -> !' )
        unset edge_attributes
        [[ $show_elapsed ]] && edge_attributes="label=\"$edge_value_label\" fontsize=$fontsize"
        [[ $scaled_object == "edge" ]] && edge_attributes+=" penwidth=$size"
        [[ $edge_attributes ]] && edge_attributes="[${edge_attributes}]"
        echo -e "\t$relationship $edge_attributes"
    fi
done

echo "}"
