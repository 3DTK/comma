#!/bin/bash

## @page background_launcher background_launcher
# @description a wrapper to start background processes; immediately after launch writes
# its own PID into a provided FIFO pipe, for the caller to verify, and then exec for the second
# time to run own command line in the same process id. Overall, it is fork-exec-exec process.
# @param fifo the named pipe to write the own PID into
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
function background_launcher()
{
    local self=$BASHPID
    local fifo=$1
    shift
    builtin echo "$FUNCNAME: run in PID '$self'" >&2
    [[ -p "$fifo" ]] || { echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    echo "$self" > "$fifo"
    builtin echo "$FUNCNAME: in PID '$self': exec '${@}'" >&2
    exec "${@}"
}
export -f background_launcher
declare -r background_launcher

## @page verify_background_process_id verify_background_process_id
# @description verify the process id of the background process as returned by bash
# in $! variable and passed through the named pipe.
# @param fifo named pipe
# @param expected the expected process id
function verify_background_process_id()
{
    local fifo=$1
    local expected=$2
    local pid status
    local timeout=10
    # http://stackoverflow.com/questions/6448632/read-not-timing-out-when-reading-from-pipe-in-bash
    # Your shell is blocking on the open() call before invoking the read builtin.
    #
    # On Linux, you can open the FIFO for both read and write at the same time to prevent blocking on open; this is non-portable, but may do what you want.
    builtin echo "$FUNCNAME: attempt to read pid from '$fifo' for $timeout seconds ..." >&2
    read -t $timeout pid <> "$fifo"
    status=$?
    (( status == 0 )) || {
        builtin echo "$FUNCNAME: could not read process id from '$fifo' in $timeout seconds or read error, status '$status'" >&2
        return 1
    }
    [[ "$pid" == "$expected" ]] || {
        builtin echo "$FUNCNAME: expected to get a pid of '$expected', but read '$pid'" >&2
        return 1
    }
    builtin echo "$FUNCNAME: expected pid '$expected', read pid '$pid'; success" >&2
    return 0
}
export -f verify_background_process_id
declare -r verify_background_process_id

## @page launch_background_and_verify launch_background_and_verify
# @description launch the given command as a background process and verify its pid
# by passing it through a fifo and checking against $! variable. If verification passed,
# the value still stored in $! is safe to use. Note that if a signal interrupt occurs
# before or during verification, nothing is certain about $! and reliable signal handlers
# shall bluntly kill all child processes.
# @param fifo named pipe
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
# @return 0 on verification success, 1 on failure
function launch_background_and_verify()
{
    local fifo=$1
    shift
    local child
    background_launcher "$fifo" "$@" & child=$!
    verify_background_process_id "$fifo" "$child"
}
export -f launch_background_and_verify
declare -r launch_background_and_verify
