#!/bin/bash

function usage()
{
    echo >&2
    echo "take path-value pairs from stdin, calculate given output values" >&2
    echo >&2
    echo "this is a prototype of the rule engine" >&2
    echo >&2
    echo "usage: cat input.path-value | name-value-calc <expr> > output.path-value" >&2
    echo >&2
    echo "    <expr>: a file containing a python-like script using input values" >&2
    echo >&2
    echo "    todo: more convenient and intuitive output value parsing" >&2
    echo >&2
    echo "    example" >&2
    echo "        # sample script" >&2
    echo "        cat expr.txt" >&2
    echo "        if aircraft.type == \"B747\" and arrival.runway.length > 1500 :" >&2
    echo "            max_landing_weight=250000" >&2
    echo "        else :" >&2
    echo "            max_landing_weight=220000" >&2
    echo "        print \"aircraft/max_landing_weight=\", max_landing_weight" >&2
    echo >&2
    echo "        # running it" >&2
    echo "        cat << EOF | name-value-calc expr.txt" >&2
    echo "        arrival/runway/length=1200" >&2
    echo "        aircraft/type=\"B747\"" >&2
    echo "        EOF" >&2
    echo >&2
    exit 1
}

if [[ "$1" == "" || "$1" == "--help" || "$1" == "-h" ]] ; then usage ; fi

function escaped()
{
    echo $1 | sed 's/\//__/g'
}

function dotted()
{
    echo $1 | sed 's/__/\\\./g'
}

declare -A values
function fill_values()
{
    while IFS='=' read name value ; do
        if [[ "$name" == "" ]] ; then continue ; fi
        if [[ "$value" == "" ]] ; then value="\"\"" ; fi
        values[$( escaped $name )]="$value"
    done
}

# todo
function fill_output_names
{
    while IFS=' ' read cmd name ; do
        if [[ "$cmd" != "print" || "$name" == "" ]] ; then continue ; fi
        output_names+=( "$name" )
    done < $1
}

function names
{
    for name in ${!values[@]} ; do echo $name ; done \
        | awk '{ print length($0) " " $0; }' \
        | sort --reverse -n \
        | cut -d ' ' -f 2
}

function substitute
{
    echo > /dev/null
}

# todo: optionally take json
#name-value-convert --from json --to path-value

fill_values

# quick and dirty, just to prove the concept
current=$( basename $1 )
for name in $( names ; ${output_names[@]} ) ; do
    next=$( mktemp $1.XXXX.tmp )
    cat $current | sed "s/$( dotted $name )/${values[$name]}/g" > $next
    current=$next
done
#final=$( mktemp $1.XXXX.tmp )
#cat $current | sed 's/print .* > $final
#python -s $final
python -s $current

rm $1.*.tmp

exit

# todo: remove all below, just poking around
cat $1 \
    | sed 's/$/ __eol__/g' \
    | sed "s/[a-zA-Z]\{1\}[-_a-zA-Z0-9]*\(\.[a-zA-Z]\{1\}[-_a-zA-Z0-9]*\)*/\n__name__=&\n/g" \
    | while read line ; do
         name=$( echo $line | grep "__name__=" | grep -v "__eol__" | sed 's/__name__=//g' | sed 's/_/__/g' | sed 's/\./_/g' )
         if [ -z "$name" ] ; then echo $line ; else echo " $name " ; fi
      done



