#!/bin/bash

# This file is part of comma, a generic and flexible library
# Copyright (c) 2011 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# this script is designed to be included in another script directly, for example:
# source $( type -p comma-process-util )

## @page comma-background-util comma-background-util
# @brief functions used to start background processes and verify their process ids
#
# @section comma_background_util_constants Constants
# @li @link COMMA_KILL_SIGNED_NOT_FOUND @endlink
# @li @link COMMA_KILL_SIGNED_REUSED @endlink
#
# @section comma_background_util_functions Functions
# @li @link comma_get_process_signature @endlink
# @li @link comma_kill_signed @endlink
# @li @link comma_background_launcher @endlink
# @li @link comma_verify_background_pid @endlink
# @li @link comma_background_and_verify_pid @endlink

[[ -n "$comma_background_util_include_guard_" ]] && return 0
readonly comma_background_util_include_guard_=1

# @description parse /proc/{pid} directory to build a unique descriptor
# of the process with the given process id. Safe to call from the process
# itself. If called from outside, the caller must make sure that the process
# in question does not disappear mid-call, most typically, send it SIGSTOP
# and ensure that SIGCONT is issued even if the caller itself terminates
# abruptly, such as killed by signal. The signature is written to stdout.
# @param pid process id to query
# @return 0 on success, 1 on error (likely, given PID does not exist),
function comma_get_process_signature()
{
    local verbose=0
    local pid=$1
    [[ "$pid" == "--verbose" ]] && { verbose=1 ; shift ; pid=$1 ; }
    local signature
    signature=$( ps --no-headers -o lstart $pid )
    (( $? == 0 )) || { builtin echo "$FUNCNAME: process with id '$pid' not found" >&2; return 1; }
    signature=$( date --date="$signature" +%Y%m%dT%H%M%S ) || { builtin echo "$FUNCNAME: cannot convert '$signature' to timestamp" >&2; return 1; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: process '$pid' signed as '$signature'" >&2
    echo "$signature"
}
export -f comma_get_process_signature
declare -r comma_get_process_signature

## @page COMMA_KILL_SIGNED_ERROR COMMA_KILL_SIGNED_ERROR
# @brief exit status of @link comma_kill_signed @endlink in case of internal errors
export COMMA_KILL_SIGNED_ERROR=1
declare -r COMMA_KILL_SIGNED_ERROR

## @page COMMA_KILL_SIGNED_NOT_FOUND COMMA_KILL_SIGNED_NOT_FOUND
# @brief exit status of @link comma_kill_signed @endlink if the process to be killed is not in the process tree (terminated already)
export COMMA_KILL_SIGNED_NOT_FOUND=3
declare -r COMMA_KILL_SIGNED_NOT_FOUND

## @page COMMA_KILL_SIGNED_REUSED COMMA_KILL_SIGNED_REUSED
# @brief exit status of @link comma_kill_signed @endlink if the process to be killed shows a different signature (PID reused)
export COMMA_KILL_SIGNED_REUSED=4
declare -r COMMA_KILL_SIGNED_REUSED

# @description check if the given process id has the given descriptor
# (see @link comma_get_process_signature @endlink) and kill it with TERM if so.
# Does nothing if the process is not found.
# @param pid process id to query; start with '-' to kill the process group
# @param signature unique process descriptor to compare
# @return 0 on success (process found, signature matched, process killed), @link COMMA_KILL_SIGNED_NOT_FOUND @endlink
# on internal errors (cannot determine current process signature), @link COMMA_KILL_SIGNED_NOT_FOUND @endlink
# if the process is not found (already terminated), and @link COMMA_KILL_SIGNED_REUSED @endlink on signature mismatch;
# the last two cases may or may not be errors, only the user knows if the process being
# killed is expected to exist or can exit by itself before calling this function
function comma_kill_signed()
{
    # TODO provide '--verbose' mode
    local pid=$1
    local signature=$2
    local group=${pid:0:1}
    [[ "$group" == "-" ]] && pid=${pid:1} || group=""
    trap "builtin kill -s CONT $pid; trap - RETURN" RETURN
    builtin kill -s STOP $pid
    (( $? == 0 )) || { builtin echo "$FUNCNAME: process id '$pid' not found; do not kill, assume terminated by itself" >&2; return $COMMA_KILL_SIGNED_NOT_FOUND; }
    local current
    current=$( comma_get_process_signature $pid )
    (( $? == 0 )) || { builtin echo "$FUNCNAME: cannot get signature of process id '$pid'" >&2; return $COMMA_KILL_SIGNED_ERROR; }
    [[ "$current" == "$signature" ]] || { builtin echo "$FUNCNAME: process '$pid' has signature '$current' different from expected '$signature'; possibly re-used; refuse to kill" >&2; return $COMMA_KILL_SIGNED_REUSED; }
    # TODO allow the user to specify the signal to use for killing
    builtin kill -s TERM ${group}${pid}
}
export -f comma_kill_signed
declare -r comma_kill_signed

## @page comma_background_launcher comma_background_launcher
# @description a wrapper to start background processes; immediately after launch writes
# its own PID into a provided FIFO pipe, for the caller to verify, and then exec for the second
# time to run own command line in the same process id. Overall, it is fork-exec-exec process.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param fifo the named pipe to write the own PID into
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
function comma_background_launcher()
{
    local self=$BASHPID
    local verbose=0
    local fifo=$1 ; shift
    [[ "$fifo" == "--verbose" ]] && { verbose=1 ; fifo=$1 ; shift ; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: run in PID '$self'" >&2
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local signature
    signature=$( comma_get_process_signature $self ) || { builtin echo "$FUNCNAME: cannot get process signature for '$self'" >&2; return 1; }
    builtin echo "$self $signature" > "$fifo"
    (( verbose == 0 )) || builtin echo "$FUNCNAME: in PID '$self': exec '${@}'" >&2
    unset verbose self fifo signature
    exec "${@}"
}
export -f comma_background_launcher
declare -r comma_background_launcher

## @page comma_verify_background_pid comma_verify_background_pid
# @description verify the process id of the background process as returned by bash
# in $! variable and passed through the named pipe. Assign the global variable
# comma_background_signature to the signature of the background process.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param fifo the named pipe to read PID from
# @param expected the expected process id
function comma_verify_background_pid()
{
    local verbose=0
    local fifo=$1
    [[ "$fifo" == "--verbose" ]] && { verbose=1 ; shift; fifo=$1 ; }
    local expected=$2
    local pid status
    local timeout=10
    # http://stackoverflow.com/questions/6448632/read-not-timing-out-when-reading-from-pipe-in-bash
    # Your shell is blocking on the open() call before invoking the read builtin.
    #
    # On Linux, you can open the FIFO for both read and write at the same time to prevent blocking on open; this is non-portable, but may do what you want.
    (( verbose == 0 )) || builtin echo "$FUNCNAME: attempt to read pid from '$fifo' for $timeout seconds ..." >&2
    # TODO provide an option to control the name of the signature variable, e.g., --signature-name=variable_name; exec the assignment
    read -t $timeout pid comma_background_signature <> "$fifo"
    status=$?
    (( status == 0 )) || {
        builtin echo "$FUNCNAME: could not read process id from '$fifo' in $timeout seconds or read error, status '$status'" >&2
        return 1
    }
    [[ "$pid" == "$expected" ]] || {
        builtin echo "$FUNCNAME: expected to get a pid of '$expected', but read '$pid'" >&2
        return 1
    }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: expected pid '$expected', read pid '$pid'; success" >&2
    return 0
}
export -f comma_verify_background_pid
declare -r comma_verify_background_pid

## @page comma_background_and_verify_pid comma_background_and_verify_pid
# @description launch the given command as a background process and verify its pid
# by passing it through a fifo and checking against $! variable. If verification passed,
# the value still stored in $! is safe to use. Note that if a signal interrupt occurs
# before or during verification, nothing is certain about $! and reliable signal handlers
# shall bluntly kill all child processes.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param fifo named pipe to use for passing PID from background process to verifier
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
# @return 0 on verification success, 1 on failure
function comma_background_and_verify_pid()
{
    local verbose=
    local fifo=$1 ; shift
    [[ "$fifo" == "--verbose" ]] && { verbose="--verbose" ; fifo=$1 ; shift ; }
    local child
    comma_background_launcher $verbose "$fifo" "$@" & child=$!
    comma_verify_background_pid $verbose "$fifo" "$child"
}
export -f comma_background_and_verify_pid
declare -r comma_background_and_verify_pid
