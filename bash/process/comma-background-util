#!/bin/bash

# This file is part of comma, a generic and flexible library
# Copyright (c) 2011 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# this script is designed to be included in another script directly, for example:
# source $( type -p comma-process-util )

## @page comma-background-util comma-background-util
# @brief functions used to start background processes and verify their process ids
#
# @section comma_background_util_constants Constants
# @li @link COMMA_PROCESS_KILL_ERROR @endlink
# @li @link COMMA_PROCESS_KILL_NOT_FOUND @endlink
# @li @link COMMA_PROCESS_KILL_REUSED @endlink
#
# @section comma_background_util_functions Functions
# @li @link comma_process_signature @endlink
# @li @link comma_process_kill_trap_return_ @endlink
# @li @link comma_process_kill @endlink
# @li @link comma_process_exec @endlink
# @li @link comma_process_validate @endlink
# @li @link comma_process_exec_and_validate @endlink

[[ -n "$comma_background_util_include_guard_" ]] && return 0
readonly comma_background_util_include_guard_=1

## @page comma_process_signature comma_process_signature
# @description parse /proc/{pid} directory to build a unique descriptor
# of the process with the given process id. Safe to call from the process
# itself. If called from outside, the caller must make sure that the process
# in question does not disappear mid-call, most typically, send it SIGSTOP
# and ensure that SIGCONT is issued even if the caller itself terminates
# abruptly, such as killed by signal. The signature is written to stdout.
# @param pid process id to query
# @return 0 on success, 1 on error (likely, given PID does not exist),
function comma_process_signature()
{
    local verbose=0
    local pid=$1
    [[ "$pid" == "--verbose" ]] && { verbose=1 ; shift ; pid=$1 ; }
    local signature
    signature=$( ps --no-headers -o lstart $pid )
    (( $? == 0 )) || { builtin echo "$FUNCNAME: process with id '$pid' not found" >&2; return 1; }
    signature=$( date --date="$signature" +%Y%m%dT%H%M%S ) || { builtin echo "$FUNCNAME: cannot convert '$signature' to timestamp" >&2; return 1; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: process '$pid' signed as '$signature'" >&2
    echo "$signature"
}
export -f comma_process_signature
declare -r comma_process_signature

## @page COMMA_PROCESS_KILL_ERROR COMMA_PROCESS_KILL_ERROR
# @brief exit status of @link comma_process_kill @endlink in case of internal errors
export COMMA_PROCESS_KILL_ERROR=1
declare -r COMMA_PROCESS_KILL_ERROR

## @page COMMA_PROCESS_KILL_NOT_FOUND COMMA_PROCESS_KILL_NOT_FOUND
# @brief exit status of @link comma_process_kill @endlink if the process to be killed is not in the process tree (terminated already)
export COMMA_PROCESS_KILL_NOT_FOUND=3
declare -r COMMA_PROCESS_KILL_NOT_FOUND

## @page COMMA_PROCESS_KILL_REUSED COMMA_PROCESS_KILL_REUSED
# @brief exit status of @link comma_process_kill @endlink if the process to be killed shows a different signature (PID reused)
export COMMA_PROCESS_KILL_REUSED=4
declare -r COMMA_PROCESS_KILL_REUSED

## @page comma_process_kill_trap_return_ comma_process_kill_trap_return_
# @brief auxiliary, the return trap for @link comma_process_kill @endlink
function comma_process_kill_trap_return_()
{
    (( verbose == 1 )) && builtin echo "$FUNCNAME: send CONT to $pid" >&2
    builtin kill -s CONT $pid
    trap - RETURN
}
export -f comma_process_kill_trap_return_
declare -r comma_process_kill_trap_return_

## @page comma_process_kill comma_process_kill
# @description check if the given process id has the given descriptor
# (see @link comma_process_signature @endlink) and kill it with TERM if so.
# Does nothing if the process is not found.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param signal-to-use optional; if equal to '--signal=SIGNAL', use SIGNAL as kill argument; otherwise taken as first argument
# @param pid process id to query; start with '-' to kill the process group
# @param signature unique process descriptor to compare
# @return 0 on success (process found, signature matched, process killed), @link COMMA_PROCESS_KILL_NOT_FOUND @endlink
# on internal errors (cannot determine current process signature), @link COMMA_PROCESS_KILL_NOT_FOUND @endlink
# if the process is not found (already terminated), and @link COMMA_PROCESS_KILL_REUSED @endlink on signature mismatch;
# the last two cases may or may not be errors, only the user knows if the process being
# killed is expected to exist or can exit by itself before calling this function
function comma_process_kill()
{
    local verbose=0
    local signal_to_use="TERM"
    while true; do
        case $1 in
            --signal=*) signal_to_use=${1#*=};;
            --verbose)  verbose=1;;
            *)          break;;
        esac
        shift
    done
    local pid=$1
    local signature=$2
    local group=${pid:0:1}
    [[ "$group" == "-" ]] && pid=${pid:1} || group=""
    (( verbose == 1 )) && builtin echo "$FUNCNAME: send signal '$signal_to_use' to ${group}${pid}" >&2
    trap 'comma_process_kill_trap_return_' RETURN
    builtin kill -s STOP $pid
    (( $? == 0 )) || { builtin echo "$FUNCNAME: process id '$pid' not found; do not kill, assume terminated by itself" >&2; return $COMMA_PROCESS_KILL_NOT_FOUND; }
    local current
    current=$( comma_process_signature $pid )
    (( $? == 0 )) || { builtin echo "$FUNCNAME: cannot get signature of process id '$pid'" >&2; return $COMMA_PROCESS_KILL_ERROR; }
    [[ "$current" == "$signature" ]] || { builtin echo "$FUNCNAME: process '$pid' has signature '$current' different from expected '$signature'; possibly re-used; refuse to kill" >&2; return $COMMA_PROCESS_KILL_REUSED; }
    (( verbose == 1 )) && builtin echo "$FUNCNAME: verification passed, do 'kill -s $signal_to_use ${group}${pid}'" >&2
    builtin kill -s $signal_to_use ${group}${pid}
}
export -f comma_process_kill
declare -r comma_process_kill

## @page comma_process_exec comma_process_exec
# @description a wrapper to start background processes; immediately after launch writes
# its own PID into a provided FIFO pipe, for the caller to verify, and then exec for the second
# time to run own command line in the same process id. Overall, it is fork-exec-exec process.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param fifo the named pipe to write the own PID into
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
function comma_process_exec()
{
    local self=$BASHPID
    local verbose=0
    local fifo=$1 ; shift
    [[ "$fifo" == "--verbose" ]] && { verbose=1 ; fifo=$1 ; shift ; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: run in PID '$self'" >&2
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local signature
    signature=$( comma_process_signature $self ) || { builtin echo "$FUNCNAME: cannot get process signature for '$self'" >&2; return 1; }
    timeout -s TERM -k 10 10 bash -c "builtin echo \"$self $signature\" > \"$fifo\""
    local rv=$?
    (( rv == 0 )) || { builtin echo "$FUNCNAME: write into the named pipe '$fifo' failed, error $rv" >&2; return $rv; }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: in PID '$self': exec '${@}'" >&2
    unset verbose self fifo signature
    exec "${@}"
}
export -f comma_process_exec
declare -r comma_process_exec

## @page comma_process_validate comma_process_validate
# @description verify the process id of the background process as returned by bash
# in $! variable and passed through the named pipe. Also, read the signature of the background
# process (calculated in the child itself and passed through the same named pipe) and store it
# in a global variable; the user can contol the variable name through command-line options.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param variable optional; if equal to '--signature-variable=NAME', assign variable NAME to the signature
# of the background process; otherwise taken as first argument; default name: comma_process_child_signature
# @param fifo the named pipe to read PID from
# @param expected the expected process id
function comma_process_validate()
{
    local verbose=0
    local signature_variable_name="comma_process_child_signature"
    while true; do
        case $1 in
            --signature-variable=*) signature_variable_name=${1#*=};;
            --verbose)              verbose=1;;
            *)                      break;;
        esac
        shift
    done
    local fifo=$1
    local expected=$2
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local pid status signature
    local timeout=10
    # http://stackoverflow.com/questions/6448632/read-not-timing-out-when-reading-from-pipe-in-bash
    # Your shell is blocking on the open() call before invoking the read builtin.
    #
    # On Linux, you can open the FIFO for both read and write at the same time to prevent blocking on open; this is non-portable, but may do what you want.
    (( verbose == 0 )) || builtin echo "$FUNCNAME: attempt to read pid from '$fifo' for $timeout seconds ..." >&2
    read -t $timeout pid signature <> "$fifo"
    status=$?
    (( status == 0 )) || {
        builtin echo "$FUNCNAME: could not read process id from '$fifo' in $timeout seconds or read error, status '$status'" >&2
        return 1
    }
    [[ "$pid" == "$expected" ]] || {
        builtin echo "$FUNCNAME: expected to get a pid of '$expected', but read '$pid'" >&2
        return 1
    }
    (( verbose == 0 )) || builtin echo "$FUNCNAME: expected pid '$expected', read pid '$pid'; success" >&2
    eval "$signature_variable_name=$signature"
    return 0
}
export -f comma_process_validate
declare -r comma_process_validate

## @page comma_process_exec_and_validate comma_process_exec_and_validate
# @description launch the given command as a background process and verify its pid
# by passing it through a fifo and checking against $! variable. If verification passed,
# the value still stored in $! is safe to use. Note that if a signal interrupt occurs
# before or during verification, nothing is certain about $! and reliable signal handlers
# shall bluntly kill all child processes.
# @param verbosity optional; if equal to '--verbose', print trace messages; otherwise taken as first argument
# @param variable optional, see @link comma_process_validate @endlink for details
# @param fifo named pipe to use for passing PID from background process to verifier
# @param command the entire command line (multiple arguments, if needed) to be exec-ed
# @return 0 on verification success, 1 on failure
function comma_process_exec_and_validate()
{
    local args=
    local verbose=
    while true; do
        case $1 in
            --signature-variable=*) args+=" $1";;
            --verbose)              args+=" $1"; verbose+="$1";;
            *)                      break;;
        esac
        shift
    done
    local fifo=$1 ; shift
    [[ -p "$fifo" ]] || { builtin echo "$FUNCNAME: '$fifo' is not a FIFO" >&2; return 1; }
    local child
    comma_process_exec $verbose "$fifo" "$@" & child=$!
    comma_process_validate $args "$fifo" "$child"
}
export -f comma_process_exec_and_validate
declare -r comma_process_exec_and_validate
