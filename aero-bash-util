#!/bin/bash

[ -n "$aero_bash_util_include_guard_" ] && return || readonly aero_bash_util_include_guard_=1

# take path-value pairs, assign the values to corresponding bash variables
# in the variable name slashes will be replaced with given delimiter
#
# delimiter: default '_'
# dash '-': replaced with '_'
# lines starting with '#' ignored
# empty lines ignored
#
# $1: variable name prefix
# $2: slash replacement; default: _
#
# examples (try them):
#     aero_path_value_eval < <( echo hello=world )
#     echo $hello
#
#     aero_path_value_eval < <( echo hello/world=bye )
#     echo $hello__world
#
#     aero_path_value_eval blah < <( echo hello/world=bye )
#     echo $blah__hello__world
function aero_path_value_to_var()
{
    local prefix=$1
    local path
    local value
    local name
    local delimiter="_"
    if [ ! -z $2 ] ; then delimiter="$2" ; fi
    if [ ! -z $1 ] ; then prefix="$1$delimiter" ; fi
    while IFS='=' read path value ; do
        if [[ "$path" == "" ]] ; then continue ; fi
        if [[ "$path" =~ "#" ]] ; then continue ; fi
        if [[ "$value" == "" ]] ; then continue ; fi
        name=$prefix$( echo $path | sed "s/\//$delimiter/g" | sed "s/-/_/g" )
        eval $name=\"$value\"
    done
}

# todo: debug...
#
# take path-value pairs, output the values of corresponding bash variables
# in the variable name slashes will be replaced with given delimiter
#
# delimiter: default '_'
# dash '-': replaced with '_'
# lines starting with '#' ignored
# empty lines ignored
#
# $1: variable name prefix
# $2: slash replacement; default: _
#
# examples (try them):
#     todo
function aero_path_value_from_var()
{
    local prefix=$1
    local path
    local value
    local default_value
    local name
    local delimiter="_"
    if [ ! -z $2 ] ; then delimiter="$2" ; fi
    if [ ! -z $1 ] ; then prefix="$1$delimiter" ; fi
    while IFS='=' read path default_value ; do
        if [[ "$path" == "" ]] ; then continue ; fi
        if [[ "$path" =~ "#" ]] ; then continue ; fi
        name=$prefix$( echo $path | sed "s/\//$delimiter/g" | sed "s/-/_/g" )
        eval value=\$$name
        [[ "$value" == "" && "$default_value" != "" ]] && value=$default_value
        [[ "$value" != "" ]] && echo "$path=$value"
    done
}

# a coarse elapsed time estimate of <command> execution appended to <file>
# the rationale of writing to a file is to have no side effects for <command>
# usage: aero_elapsed <file> <command> <args>
function aero_elapsed()
{
    local output_file=$1
    local name=$( basename $2 )
    local start=$( date +%s.%N )
    ${@:2}
    local end=$( date +%s.%N )
    local elapsed=$( echo "$end - $start" | bc )
    echo "$name/seconds=$elapsed" >> $output_file
}


function replace_value_in_name_value()
{
    local input_string=$1
    local config_replace_list=$2
    local input_kay
    local input_value_old
    local input_value_new
    local pair
    local from_value
    local to_value
    local assignment="="
    for pair in "${config_replace_list[@]}" ; do
        from_value=${pair%%$assignment*}
        to_value=${pair##*$assignment}

        input_key=${input_string%%$assignment*}
        input_value_old=${input_string##*$assignment}
        input_value_new=${input_value_old/$from_value/$to_value}
        if [[ "$input_value_new" != "$input_value_old" ]]; then
            echo "$input_key""$assignment""$input_value_new"
            return
        fi
    done
    echo "$1"
}

function extract_config_replace_list()
{
    local result=""
    local lines=()
    local line
    local keyword="@"
    local keyword_length=${#keyword[@]}

    while read -r line
    do
        if [[ "${line:0:$keyword_length}" == "$keyword" ]]; then
            #s1=${line%%$keyword*}
            s2=${line##*$keyword}
            config_replace_list+=( "$s2" )
        else
            lines+=( "$line" )
        fi
    done

    for line in "${lines[@]}" ; do
        result+=$( replace_value_in_name_value "$line" $config_replace_list )$'\n'
    done

    echo "$result"
}