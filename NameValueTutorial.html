<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>comma: name_value tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comma
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">name_value tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The name_value library contains 2 classes, <a class="el" href="NameValueTutorial.html#NameValueParser">name_value::parser</a> and a <a class="el" href="NameValueTutorial.html#NameValueMap">name_value::map</a>.</p>
<h1><a class="anchor" id="NameValueParser"></a>
name_value::parser</h1>
<p>The purpose of the name_value parser is to serialize / deserialize plain data structures to / from a name-value format: </p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;name1=value1;name2=value2;nested/name=value3&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="NameValueTutorialGet"></a>
Getting a structure from a string</h2>
<p>Let's declare a struct containing some configuration:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Config</div>
<div class="line">{</div>
<div class="line">    Config() : size(0), alpha(0), beta(0) {}</div>
<div class="line">    Config( <span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">int</span> s, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b ):</div>
<div class="line">        filename( name ), size( s ), alpha( a ), beta( b ) {}</div>
<div class="line">    std::string filename;</div>
<div class="line">    <span class="keywordtype">int</span> size;</div>
<div class="line">    <span class="keywordtype">double</span> alpha;</div>
<div class="line">    <span class="keywordtype">double</span> beta;        </div>
<div class="line">};</div>
</div><!-- fragment --><p>We need to write the visiting traits for this struct:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Ark { <span class="keyword">namespace </span>Visiting {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Traits&lt; Config &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">class</span> Visitor &gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> visit( Key, Config&amp; config, Visitor&amp; v )</div>
<div class="line">    {</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;filename&quot;</span>, config.filename );</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;size&quot;</span>, config.size );</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;alpha&quot;</span>, config.alpha );</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;beta&quot;</span>, config.beta );</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">class</span> Visitor &gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> visit( Key, <span class="keyword">const</span> Config&amp; config, Visitor&amp; v )</div>
<div class="line">    {</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;filename&quot;</span>, config.filename );</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;size&quot;</span>, config.size );</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;alpha&quot;</span>, config.alpha );</div>
<div class="line">        v.apply( <span class="stringliteral">&quot;beta&quot;</span>, config.beta );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">} } <span class="comment">// namespace Ark { namespace Visiting {</span></div>
</div><!-- fragment --><p>Now we can deserialize it from the following string:</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;filename=data.csv;size=100;alpha=0.1;beta=0.3&quot;</span>;</div>
<div class="line"><a class="code" href="classcomma_1_1name__value_1_1parser.html" title="parser for semicolon-separated name-value string">comma::name_value::parser</a> nameValue;</div>
<div class="line">Config config = nameValue.<a class="code" href="classcomma_1_1name__value_1_1parser.html#a5eccff3f044713ba92d46a90015f782b" title="get struct from string">get</a>&lt; Config &gt;( s );</div>
</div><!-- fragment --><h2><a class="anchor" id="NameValueTutorialPut"></a>
Putting a structure into a string</h2>
<p>We can serialize the structure back into a string using name_value::put()</p>
<div class="fragment"><div class="line">Config config( <span class="stringliteral">&quot;test.txt&quot;</span>, 10, 1, 2 );</div>
<div class="line">comma::name_value::name_value nameValue;</div>
<div class="line">std::string s = nameValue.<a class="code" href="classcomma_1_1name__value_1_1parser.html#a95be19eb48d2524ed84eb6168d6fdcee" title="put struct into string">put</a>( config );</div>
</div><!-- fragment --><p>Now s contains "filename=test.txt;size=10;alpha=1;beta=2"</p>
<h2><a class="anchor" id="NameValueTutorialUnNamed"></a>
Nameless values</h2>
<p>Sometimes we may want to have values without names, for example to write shorter command line options. For example, we can write "test.txt;size=10;alpha=1;beta=2", omitting that test.txt is the file name. In that case, we can pass default names to the name_value parser, which will be added to the name-less values:</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;data.csv;size=100;alpha=0.1;beta=0.3&quot;</span>;</div>
<div class="line"><a class="code" href="classcomma_1_1name__value_1_1parser.html" title="parser for semicolon-separated name-value string">comma::name_value::parser</a> nameValue( <span class="stringliteral">&quot;filename&quot;</span> );</div>
<div class="line">Config config = nameValue.get&lt; Config &gt;( s );</div>
</div><!-- fragment --><p>The default names can be passed as comma separated fields. For example, if we also don't want to write the name "alpha", we can do:</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;data.csv;size=100;0.1;beta=0.3&quot;</span>;</div>
<div class="line"><a class="code" href="classcomma_1_1name__value_1_1parser.html" title="parser for semicolon-separated name-value string">comma::name_value::parser</a> nameValue( <span class="stringliteral">&quot;filename,,alpha&quot;</span> );</div>
<div class="line">Config config = nameValue.get&lt; Config &gt;( s );</div>
</div><!-- fragment --><h2><a class="anchor" id="NameValueTutorialNested"></a>
Nested structures</h2>
<p>The name_value parser also supports nested structures. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Nested</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> a;</div>
<div class="line">    <span class="keywordtype">int</span> b;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>Config</div>
<div class="line">{</div>
<div class="line">    std::string filename;</div>
<div class="line">    <span class="keywordtype">int</span> size;</div>
<div class="line">    <span class="keywordtype">double</span> alpha;</div>
<div class="line">    Nested nested;</div>
<div class="line">    <span class="keywordtype">double</span> beta;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The nested values can be accessed via XPath:</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;filename=data.csv;size=100;alpha=0.1;nested/a=1;nested/b=2;beta=0.3&quot;</span>;</div>
<div class="line">comma::name_value::Parser nameValue;</div>
<div class="line">Config config = nameValue.get&lt; Config &gt;( s );</div>
</div><!-- fragment --><p>If fullPathAsName is set to false in the constructor and there is no name conflict between the nested structures, we can use only the leaf of the XPath: </p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;filename=data.csv;size=100;alpha=0.1;a=1;b=2;beta=0.3&quot;</span>;</div>
<div class="line">comma::name_value::Parser nameValue( <span class="charliteral">&#39;;&#39;</span>, <span class="charliteral">&#39;=&#39;</span>, <span class="keyword">false</span> );</div>
<div class="line">Config config = nameValue.get&lt; Config &gt;( s );</div>
</div><!-- fragment --><h1><a class="anchor" id="NameValueMap"></a>
name_value::map</h1>
<p>The purpose of name_value::map is to extract name-value pairs out of a string in name-value format: </p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;name1=value1;name2=value2;nested/name=value3&quot;</span></div>
</div><!-- fragment --><p>On construction, name_value::map parses the input string and constructs a map of name-value pairs. This map can be queried with the exists() and value() functions. The value() method supports default values. </p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;filename=data.csv;size=100;alpha=0.1;beta=0.3&quot;</span>;</div>
<div class="line"><a class="code" href="classcomma_1_1name__value_1_1map.html">comma::name_value::map</a> nameValue( s );</div>
<div class="line"><span class="keywordtype">bool</span> hasFileName = nameValue.exists( <span class="stringliteral">&quot;filename&quot;</span> ); <span class="comment">// will be true</span></div>
<div class="line"><span class="keywordtype">bool</span> hasType = nameValue.exists( <span class="stringliteral">&quot;type&quot;</span> ); <span class="comment">// will be false</span></div>
<div class="line"><span class="keywordtype">double</span> alpha = nameValue.value&lt;<span class="keywordtype">double</span>&gt;( <span class="stringliteral">&quot;alpha&quot;</span> ); <span class="comment">// will be 0.1</span></div>
<div class="line"><span class="keywordtype">double</span> gamma = nameValue.value&lt;<span class="keywordtype">double</span>&gt;( <span class="stringliteral">&quot;gamma&quot;</span>, 0.2 ); <span class="comment">// will be 0.2</span></div>
</div><!-- fragment --><p>name_value::map supports names without values:</p>
<div class="fragment"><div class="line">std::string s = <span class="stringliteral">&quot;filename=data;binary&quot;</span>;</div>
<div class="line"><a class="code" href="classcomma_1_1name__value_1_1map.html">comma::name_value::map</a> nameValue( s );</div>
<div class="line"><span class="keywordtype">bool</span> binary = nameValue.exists( <span class="stringliteral">&quot;binary&quot;</span> ); <span class="comment">// will be true</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 9 2012 13:32:46 for comma by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
