#!/bin/bash

# This file is part of comma, a generic and flexible library
# Copyright (c) 2011 The University of Sydney
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University of Sydney nor the
#    names of its contributors may be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
# GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
# HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function usage()
{
    echo >&2
    echo "take csv from stdin, output path-value pairs to stdout" >&2
    echo >&2
    echo "usage: data.csv | name-value-from-csv <fields> [<options>]" >&2
    echo >&2
    echo "limitations: currently, white spaces and unescaped line breaks" >&2
    echo "             in values are not supported" >&2
    echo >&2
    echo "options" >&2
    echo "    --output-line-number,--line-number,-n: output line numbers (see examples)" >&2
    echo "    --no-brackets: use with --line-number option above, it does not output line numbers in square brackets." >&2
    echo "    --delimiter,-d <delimiter>: default: ," >&2
    echo "    --fields,-f <fields>: csv of field names" >&2
    echo "    --force: accept lines with more fields than expected" >&2
    echo "    --prefix,-p <prefix>: append this prefix to all paths" >&2
    echo "    --end-of-line,--eol <delimiter>: end of line output delimiter; default: end of line" >&2
    echo >&2
    echo "examples" >&2
    echo "    echo 1,2,3 | name-value-from-csv a,b,c/d -d ," >&2
    echo "    a=1,b=2,c/d=3" >&2
    echo >&2
    echo "    echo -e \"1,2,3\n4,5,6\" | name-value-from-csv a,b,c/d -d , --line-number" >&2
    echo "    [0]/a=1,[0]/b=2,[0]/c/d=3" >&2
    echo "    [1]/a=4,[1]/b=5,[1]/c/d=6" >&2
    echo >&2
    echo "    echo -e \"1,2,3\n4,5,6\" | name-value-from-csv --prefix airports/ a,b,c/d  --line-number --no-brackets" >&2
    echo "    airports/0/a=1" >&2
    echo "    airports/0/b=2" >&2
    echo "    airports/0/c/d=3" >&2
    echo "    airports/1/a=4" >&2
    echo "    airports/1/b=5" >&2
    echo "    airports/1/c/d=6" >&2
    echo >&2
    exit 1
}

unset prefix
force=1 # todo: set to 0, once tests pass
left_bracket='['
right_bracket=']'
delimiter=","
end_of_line=$'\n'
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help) usage ;;
        --delimiter|-d) shift ; delimiter=$1 ;;
        --delimiter=*|-d=*) delimiter=${1#*=} ;;
        --end-of-line|--eol) shift ; end_of_line=$1 ;;
        --end-of-line=*|--eol=*) end_of_line=${1#*=} ;;
        --prefix|-p) shift ; prefix=${1} ;;
        --prefix=*|-p=*) prefix=${1#*=} ;;
        --no-brackets) unset left_bracket right_bracket ;;
        --force) force=1 ;;
        --fields|-f) shift ; fields=$1 ;;
        --fields=*|-f=*) shift ; fields=${1#*=} ;;
        --output-line-number|--line-number|-n) output_line_numbers="true" ;;
        -*) echo "name-value-from-csv: unrecognized option '$1'" >&2 ; exit 1 ;;
        *) fields=$1 ;;
    esac
    shift
done

if [[ "$fields" == "" ]] ; then echo "name-value-from-csv: expected fields, got none" >&2 ; exit 1 ; fi
paths=()
i=0
while read path ; do paths[$i]="$path" ; (( ++i )) ; done < <( echo "$fields" | tr ',' $'\n' )
[[ -z "$prefix" || ( -n "$left_bracket" && -n "$output_line_numbers" ) ]] || prefix="$prefix/"
count=0
# otherwise, if last line does not have end of line, it gets missed
{ cat ; echo ; } \
| while read line ; do
      [[ -n "$line" ]] || continue
      unset index
      [[ -z "$output_line_numbers" ]] || index="${left_bracket}${count}${right_bracket}/"
      i=0
      echo $line \
          | tr "$delimiter" $'\n' \
          | while read value ; do
                (( i < ${#paths[@]} || $force )) || { echo "name-value-from-csv: on line $count has more than ${#path[@]} fields; use --force" >&2 ; exit 1 ; }
                value="$( echo $value | sed -e 's/^"//' -e 's/"$//' )"
                [[ -z ${paths[$i]} ]] || echo -n "${prefix}${index}${paths[$i]}=\"${value}\"$end_of_line"
                (( ++i ))
            done
      (( ++count ))
  done
