#!/bin/bash

name=$( basename $0 )

simple_usage()
{
    echo "Usage: $name <file1> <file2> ... [--add|--sub|--other-operations]" >&2
    echo "       ${name//?/ } [--json] [--echo] [-h|--help]" >&2
    if [[ $# != 0 ]]; then exit $1; fi
}

usage()
{
    simple_usage
    cat >&2 <<EOF

Perform simple calculations on corresponding values in multiple name=value or .json input files.

Only values from the first input file are included in the output. If a name does not appear in
the second (or later) input file, the value from the first input file is output unchanged.

All values in the input files are expected to be numbers. If a non-numeric value appears, it is
treated as zero (unless it only appears in the first input file, in which case it is output unchanged).

Options:

    --add               Add corresponding values in input files
    --sub|--subtract    Subtract corresponding values in file2 from file1 (only two input files permitted)
    --less              Values in file1 are less than in file2 (only two input files permitted)
                        returns 0 on success (all values satisfy the logical condition) and 1 on failure;
                        also see '--echo' below
    --less-or-equal
    --more
    --more-or-equal
    --equal
    --non-equal
    --not-equal         Akin to '--less', logical operations as the names imply
    --json              Input and output is in json format instead of name=value format
    --echo              For logical operations, instead of the true/false exit status echoes
                        the result as "1" for "true" and "0" for "false" (opposite to exit status)

Notes on comparison:
    File f1 is considered '--less' than file f2 only if this condition is true for all the data
    in the file. Therefore, "f1 --less f2" being false does not imply that "f2 --less f1" is true.
    Same constraint applies to all the other comparison operations.

Examples:

    $name f1 f2 f3 --add
        -- add all values in f1, f2 and f3

    $name f1.json f2.json --sub --json
        -- subtract all values in f2.json from f1.json (output in .json format)

    $name f1 --less f2 && echo "f1 < f2" || echo "f1 is not < f2"
        -- compares values in f1 and f2 and reports the outcome

    $name f1 f2 --less
        -- same as above; placement of '--less' does not matter

    if $name f1 f2 --less ; then some_command; fi
        -- will execute some_command if all fields in f1 are < than in f2

    v=\$( $name f1 f2 --less --echo )
        -- capture the comparison result in a variable; v is 1 if comparison is true

EOF
    if [[ $# != 0 ]]; then exit $1; fi
}

function status_ok()
{
    [[ ! "${PIPESTATUS[@]}" =~ [1-9] ]]
}

function bye()
{
    if [[ -z $1 ]] ; then exit 1 ; else exit $1; fi
}

# arguments are an error message to print
function die()
{
    echo "$name: $*" >&2
    if [[ -n "$user_log" ]]; then echo "$name: $*" >> "$user_log"; fi
    bye 1
}

function inlist()
{
    local value="$1"
    local list="$2"
    local c
    for c in $list ; do
        if [[ "$c" == "$value" ]]; then
            return 0
        fi
    done
    return 1
}

function binary_op()
{
    inlist "$1" "$( echo ${binary_operands[@]} )"
}

function logical_op()
{
    inlist "$1" "$( echo ${logical_operands[@]} )"
}

trap 'bye 1' SIGHUP SIGINT SIGTERM SIGPIPE

if [[ $# == 0 ]]; then simple_usage 1; fi

input_files=()
operation=
json_format=0
use_echo=0

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)          usage 0;;
        --add)              operation="+";;
        --sub|--subtract)   operation="-";;
        --less)             operation="<";;
        --less-or-equal)    operation="<=";;
        --more)             operation=">";;
        --more-or-equal)    operation=">=";;
        --equal)            operation="==";;
        --non-equal)        operation="!=";;
        --not-equal)        operation="!=";;
        --json)             json_format=1;;
        --echo)             use_echo=1;;
        -*)                 echo "$name: unrecognized option '$1'" >&2; exit 1;;
        *)                  input_files+=( "$1" );;
    esac
    shift
done

binary_operands=( "-" "<" "<=" ">" ">=" "==" "!=" )
logical_operands=( "<" "<=" ">" ">=" "==" "!=" )

if [[ ${#input_files[@]} == 0 ]]; then simple_usage 1; fi
if [[ ${#input_files[@]} == 1 ]]; then echo "$name: at least two input files required" >&2; exit 1; fi
if [[ -z "$operation" ]]; then echo "$name: operation must be specified (e.g. --subtract)" >&2; exit 1; fi
if binary_op "$operation" && [[ ${#input_files[@]} > 2 ]]; then echo "$name: only two input files permitted with $operation operation"; exit 1; fi

for file in "${input_files[@]}"; do
    if [[ ! -f "$file" ]]; then echo "$name: cannot open '$file'" >&2; exit 1; fi
done

convert_input="cat"
convert_output="cat"

# Using '-v' does not work because it inverts the _matching_ while we need to invert the exit status only
function invert_grep_q()
{
    grep -q '0$'
    (( $? == 0 )) && exit 1 || exit 0
}

# Same as above but for $( name-value-calc --echo ... ) usage pattern
function invert_grep()
{
    grep -q '0$'
    echo $?
}

if (( json_format )); then
    convert_input="name-value-convert --from=json --to=path-value"
    convert_output="name-value-convert --from=path-value --to=json"
fi
if logical_op "$operation" ; then
    convert_output="invert_grep_q"
    (( "$use_echo" == 1 )) && convert_output="invert_grep"
fi

file_separator="@-@-@-@-@"

( for file in "${input_files[@]}"; do $convert_input < "$file"; echo $file_separator; done ) | awk '
BEGIN { first_file = 1; }

/^'$file_separator'$/ { first_file = 0; next; }

NF == 0 || /^ *#/ { next; }     # skip comments and empty lines

function strip_spaces_and_quotes(s)
{
    for (n = 1;substr(s, n, 1) == " ";n++) { }
    if (n > length(s)) { return ""; }
    for (m = length(s);substr(s, m, 1) == " ";m--) { }
    if (substr(s, n, 1) == "\"") { n++; }
    if (substr(s, m, 1) == "\"") { m--; }
    return substr(s, n, m - n + 1);
}

{
    pos = index($0, "=");
    if (pos == -1) { next; }

    name = strip_spaces_and_quotes(substr($0, 1, pos - 1));
    if (name == "") { next; }

    value = strip_spaces_and_quotes(substr($0, pos + 1));

    if (first_file) { name_val[name] = value; nth_name[++num] = name; }
    else if (name in name_val) { name_val[name] = name_val[name] '$operation' value; }
}

END \
{
    if (num == 0 && '$json_format' == 0) \
    {
        print "'$name': warning: no \"name=value\" lines found (maybe --json option was intended?)" | "cat 1>&2";
        exit;
    }

    for (n = 1;n <= num;n++) \
    {
        name = nth_name[n];
        print name "=" name_val[name];
    }
}
' | $convert_output
