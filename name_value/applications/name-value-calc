#!/bin/bash

name=$( basename $0 )

simple_usage()
{
    echo "Usage: $name <file1> <file2> ... [--add|--sub|--other-operations]" >&2
    echo "       ${name//?/ } [--json] [--echo] [-h|--help]" >&2
    if [[ $# != 0 ]]; then exit $1; fi
}

usage()
{
    simple_usage
    cat >&2 <<EOF

Perform simple calculations on corresponding values in multiple name=value or .json input files.

Only values from the first input file are included in the output. If a name does not appear in
the second (or later) input file, the value from the first input file is output unchanged.

All values in the input files are expected to be numbers. If a non-numeric value appears, it is
treated as zero (unless it only appears in the first input file, in which case it is output unchanged).

Options:

    --add                     Add corresponding values in input files
    --sub|--subtract          Subtract corresponding values in file2 from file1 (only 2 files permitted)
    --mul|--mult|--multiply   Multiply corresponding values
    --div|--divide            Divide corresponding values (only 2 files permitted; error if file2 has
                              zero values)
    --less                    Values in file1 are less than in file2 (only 2 files permitted)
    --less-or-equal
    --more
    --more-or-equal
    --equal
    --non-equal
    --not-equal               Akin to '--less', logical operations as the names imply
    --json                    Input and output is in json format instead of name=value format
    --status                  Instead of printing the results, return 0 on success (all values satisfy the
                              logical condition) and 1 on failure; applicable only to logical operations;
                              also see '--echo'
    --echo                    For logical operations, instead of the true/false exit status echoes
                              the result as "1" for "true" and "0" for "false" (opposite to exit status)

Notes on comparison:
    File f1 is considered '--less' than file f2 only if this condition is true for all the data
    in the file. Therefore, "f1 --less f2" being false does not imply that "f2 --less f1" is true.
    Same constraint applies to all the other comparison operations.

Examples:

    $name f1 f2 f3 --add
        -- add all values in f1, f2 and f3

    $name f1.json f2.json --sub --json
        -- subtract all values in f2.json from f1.json (output in .json format)

    $name f1 --less f2 && echo "f1 < f2" || echo "f1 is not < f2"
        -- compares values in f1 and f2 and reports the outcome

    $name f1 f2 --less
        -- same as above; placement of '--less' does not matter

    if $name f1 f2 --less ; then some_command; fi
        -- will execute some_command if all fields in f1 are < than in f2

    v=\$( $name f1 f2 --less --echo )
        -- capture the comparison result in a variable; v is 1 if comparison is true

EOF
    if [[ $# != 0 ]]; then exit $1; fi
}

function status_ok()
{
    [[ ! "${PIPESTATUS[@]}" =~ [1-9] ]]
}

function bye()
{
    if [[ -z $1 ]] ; then exit 1 ; else exit $1; fi
}

# arguments are an error message to print
function die()
{
    echo "$name: $*" >&2
    if [[ -n "$user_log" ]]; then echo "$name: $*" >> "$user_log"; fi
    bye 1
}

function inlist()
{
    local value="$1"
    local list="$2"
    local c
    for c in $list ; do
        if [[ "$c" == "$value" ]]; then
            return 0
        fi
    done
    return 1
}

function binary_op()
{
    inlist "$1" "$( echo ${binary_operands[@]} )"
}

function logical_op()
{
    inlist "$1" "$( echo ${logical_operands[@]} )"
}

function python_converter()
{
    python -c "import sys, operator
filesep = '$file_separator'
what = '$operation'

operands = {
             '+'  : operator.add,
             '-'  : operator.sub,
             '>'  : operator.gt,
             '>=' : operator.ge,
             '<'  : operator.lt,
             '<=' : operator.le,
             '==' : operator.eq,
             '<>' : operator.ne,
             '!=' : operator.ne,
             '/'  : operator.div,
             '*'  : operator.mul,
           }

arithmetic = [ '+', '-', '/', '*' ]

names = {}
ordered_names = []
first = True
op = operands[what]
logical = what not in arithmetic

def output( was_assigned, value, logical ):
    if was_assigned:
        return int(value) if logical else value
    else:
        return 1 if logical else value

while True:
    l = sys.stdin.readline().strip()
    if not l:
        break
    if l == filesep:
        first = False
        continue
    n, v = l.split('=')
    v = v.strip('\"')
    try:
        v = int(v)
    except ValueError:
        try:
            v = float(v)
        except ValueError:
            pass
    if first:
        names[n] = ( False, v )
        ordered_names.append( n )
    else:
        if names.has_key( n ):
            names[n] = ( True, op(names[n][1], v) )

for n in ordered_names:
    v = names[n]
    print '%s=\"%s\"' % ( n, str(output(v[0], v[1], logical)) )
"
}

# Using '-v' does not work because it inverts the _matching_ while we need to invert the exit status only
function invert_grep_q()
{
    grep -q '="0"$'
    (( $? == 0 )) && return 1 || return 0
}

# Same as above but for $( name-value-calc --echo ... ) usage pattern
function invert_grep()
{
    grep -q '="0"$'
    echo $?
}

trap 'bye 1' SIGHUP SIGINT SIGTERM SIGPIPE

if [[ $# == 0 ]]; then simple_usage 1; fi

input_files=()
operation=
json_format=0
use_echo=0
use_status=0

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)               usage 0;;
        --add)                   operation="+";;
        --sub|--subtract)        operation="-";;
        --mul|--mult|--multiply) operation="*";;
        --div|--divide)          operation="/";;
        --less)                  operation="<";;
        --less-or-equal)         operation="<=";;
        --more)                  operation=">";;
        --more-or-equal)         operation=">=";;
        --equal)                 operation="==";;
        --non-equal)             operation="!=";;
        --not-equal)             operation="!=";;
        --json)                  json_format=1;;
        --echo)                  use_echo=1;;
        --status)                use_status=1;;
        -*)                      echo "$name: unrecognized option '$1'" >&2; exit 1;;
        *)                       input_files+=( "$1" );;
    esac
    shift
done

binary_operands=( "-" "/" "<" "<=" ">" ">=" "==" "!=" )
logical_operands=( "<" "<=" ">" ">=" "==" "!=" )

if [[ ${#input_files[@]} == 0 ]]; then simple_usage 1; fi
if [[ ${#input_files[@]} == 1 ]]; then echo "$name: at least two input files required" >&2; exit 1; fi
if [[ -z "$operation" ]]; then echo "$name: operation must be specified (e.g. --subtract)" >&2; exit 1; fi
if binary_op "$operation" && [[ ${#input_files[@]} > 2 ]]; then echo "$name: only two input files permitted with $operation operation"; exit 1; fi

for file in "${input_files[@]}"; do
    if [[ ! -r "$file" ]]; then echo "$name: cannot open '$file'" >&2; exit 1; fi
done

convert_input="cat"
convert_output="cat"

if (( json_format )); then
    convert_input="name-value-convert --from=json --to=path-value"
    convert_output="name-value-convert --from=path-value --to=json"
fi
if logical_op "$operation" ; then
    (( "$use_status" == 1 )) && convert_output="invert_grep_q"
    (( "$use_echo" == 1 )) && convert_output="invert_grep"
else
    (( $use_status == 1 )) && echo "$name: warning, --status is ignored, not a logical op" >&2
    (( $use_echo == 1 )) && echo "$name: warning, --echo is ignored, not a logical op" >&2
fi

file_separator="@-@-@-@-@"

( for file in "${input_files[@]}"; do $convert_input < "$file"; echo $file_separator; done ) | python_converter | $convert_output
