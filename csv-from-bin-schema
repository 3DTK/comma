#!/bin/bash

name=$( basename $0 )

simple_usage()
{
    echo "Usage: $name [-h|--help] (<directory> <file_prefix>) | (-s|--schema=<schema> -d|--data=<data>)) (<fields> | -a|--all) [-b|--binary]" >&2
}

usage()
{ 
    simple_usage
    cat >&2 <<EOF

Extract the named fields from a "binary csv" file, given the schema (i.e. list of fields and
binary format) in a .json file.

Arguments:

  <directory>     Directory containing .bin files described by .json files (see below for format),
                  e.g. /mnt/q-storage/navigation/424/20130401T000000/bin

  <file_prefix>   The prefix of the .bin file and its corresponding .json file (containing the
                  schema: "fields" and "format" -- see example below). For example, if the
                  directory contains airports.bin and airports.json, the prefix is just "airports".

  <schema>        Name of the schema (.json) file

  <data>          Name of the data (.bin) file

  <fields>        Fields to extract and output in csv format (may be separated by spaces or commas).
                  For the example below, fields might be: "icao_code,latitude,longitude"

Options:

  -b|--binary     Output in "binary csv" format.

  -a|--all        Output all fields.

Example .json file:

  {
      "fields" : "latitude,longitude,route_specifier,id,icao_code,name,name,elevation,recommended_navaid,recommended_navaid_icao_code,ata_iata_designator",
      "format" : "d,d,s[2],s[9],s[4],s[1],s[50],uw,s[8],s[4],s[5]"
  }

Example usage:

csv-from-bin-schema /mnt/q-storage/navigation/424/bin/20130201T000000 airports latitude longitude id

csv-from-bin-schema test_dir --schema=ff.json --data=ff_poly_1.bin latitude,longitude,is_gate,waypoint_id

EOF
    exit $1
}

dir=
prefix=
schema_file=
data_file=
fields=
binary=0
print_all=0

while [[ $# -gt 0 ]]; do
    case "$1" in
    -h|--help)
        usage 0
        ;;
    -b|--binary)
        binary=1
        ;;
    -s=*|--schema=*)
        schema_file=${1#*=}
        ;;
    -d=*|--data=*)
        data_file=${1#*=}
        ;;
    -a|--all)
        print_all=1
        ;;
    -*)
        echo "$name: unrecognized option '$1'" >&2
        exit 1
        ;;
    *)  if [[ -z "$dir" ]]; then
            # if -s/-d arguments are used, dir and prefix will not be present -- these arguments
            # will just be the first two fields (which will be taken care of below)
            dir="$1"
        elif [[ -z "$prefix" ]]; then
            prefix="$1"
        else
            fields="$fields $1"
        fi
        ;;
    esac
    shift
done

if [[ -z "$schema_file" && -z "$data_file" ]]; then
    if [[ -z "$dir" || -z "$prefix" ]]; then
        simple_usage
        exit 1
    fi

    if [[ ! ( -d "$dir" ) ]]; then
        echo "$name: no such directory: '$dir'" >&2
        exit 1
    fi

    data_file="$dir/$prefix.bin"
    schema_file="$dir/$prefix.json"
else
    if [[ -z "$schema_file" || -z "$data_file" ]]; then
        echo "$name: \"--schema\" and \"--data\" must both be specified together" >&2
        exit 1
    fi

    # the values assigned to $dir and $prefix were really just the first two fields
    # (the echo is to strip extra spaces)
    fields=$( echo $dir $prefix $fields )
fi

if [[ -z "$fields" && $print_all == 0 ]]; then
    echo "$name: <fields> or \"--all\" argument missing" >&2
    exit 1
fi

if [[ ! ( -f "$data_file" ) ]]; then
    echo "$name: binary file not found: '$data_file'" >&2
    exit 1
fi

if [[ ! ( -f "$schema_file" ) ]]; then
    echo "$name: schema file not found: '$schema_file'" >&2
    exit 1
fi

field_list=$( cat "$schema_file" | name-value-get fields --from json )
format=$( cat "$schema_file" | name-value-get format --from json )

if [[ $print_all == 1 ]];
then
    fields="$field_list"
    out_format="$format"
else
    fields=$( echo $fields | sed 's/ /,/g' )
    out_format=$( echo $format | csv-shuffle --fields="$field_list" --output-fields="$fields" )
fi

if [[ $binary == 1 ]]; then
    output_cmd="tee"   # tee without arguments just copies input to stdout
else
    output_cmd="csv-from-bin $out_format"
fi

csv-shuffle --fields="$field_list" --binary="$format" --output-fields="$fields" < "$data_file" | $output_cmd
