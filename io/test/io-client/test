#!/bin/bash

timeout=1
dir=/tmp
prefix=io-client
declare -A pids
declare -A files

function bye
{
    pkill -P $$
    rm -f ${files[@]}
    kill -9 ${pids[@]} &>/dev/null
    exit 1
}

trap bye INT TERM HUP

function find_free_port
{
    local -i start=${1:-1024}
    local -i end=${2:-65535}
    if (( start < 1024 )); then echo "$FUNCNAME: expected start port to be from 1024 to 65535, got $start" >&2; return; fi
    if (( end > 65535 )); then echo "$FUNCNAME: expected end port to be from 1024 to 65535, got $end" >&2; return; fi
    if (( start > end )); then echo "$FUNCNAME: expected start <= end, got start = $start and end = $end" >&2; return; fi
    for(( port=start; port <= end; port++ )); do
        if ! netstat -ltun | grep $port &>/dev/null; then echo $port && return; fi
    done
}

function wait_for_success
{
    reps=10
    dt=0.1
    for(( i=0; i<$reps; i++ )); do
        eval "$1" && return 0 || sleep $dt
    done
    echo "condition '$1' has not been satisfied in the alloted $( bc -l <<< "$reps*$dt" ) seconds" >&2
    return 1
}

function test_tcp
{
    local message="tcp_message1\ntcp_message2"
    local condition="netstat -ltn | grep $port &>/dev/null"
    echo -e "$message" | socat -u - tcp-listen:$port,reuseaddr & pids[tcp]=$!
    output=$( wait_for_success "$condition" && timeout -k 1 -s TERM $timeout io-client -u tcp:localhost:$port | tail -n1 )
    echo "tcp/output=\"$output\""
    kill ${pids[tcp]} &>/dev/null
    wait ${pids[tcp]}
}

function test_udp
{
    local message="udp_message1\nudp_message2"
    local condition="netstat -lun | grep $port &>/dev/null"
    wait_for_success "$condition" && echo -e "$message" | socat - udp-sendto:localhost:$port & pids[udp]=$!
    output=$( timeout -k 1 -s TERM $timeout io-client -u udp:$port | tail -n1 )
    echo "udp/output=\"$output\""
    kill ${pids[udp]} &>/dev/null
    wait ${pids[udp]}
}

function test_socket
{
    files[socket]=$dir/${prefix}_socket
    local message="local_message1\nlocal_message2"
    local condition="test -S ${files[socket]}"
    rm -f ${files[socket]}
    echo -e "$message" | socat -u - unix-listen:${files[socket]} & pids[socket]=$!
    output=$( wait_for_success "$condition" && timeout -k 1 -s TERM $timeout io-client -u local:${files[socket]} | tail -n1 )
    echo "socket/output=\"$output\""
    kill ${pids[socket]} &>/dev/null
    wait ${pids[socket]}
    rm -f ${files[socket]}
}

function test_zmq_socket
{
    files[zmq_socket]=$dir/${prefix}_zmq_socket
    local message="zmq_local_message1\nzmq_local_message2"
    local condition="test -S ${files[zmq_socket]}"
    rm -f ${files[zmq_socket]}
    exec 3> >( zero-cat --publish ipc://${files[zmq_socket]} ) && wait_for_success "$condition" && echo -e "$message" >&3 && exec 3<&- &
    output=$( timeout -k 1 -s TERM $timeout io-client -u zmq-local:${files[zmq_socket]} | tail -n1 )
    echo "zmq_socket/output=\"$output\""
    rm -f ${files[zmq_socket]}
}

function test_zmq_tcp
{
    # todo
    echo "$FUNCNAME is not implemented" >&2
}

function test_file
{
    files[file]=$dir/${prefix}_file
    local message="file_message1\nfile_message2"
    echo -e "$message" > ${files[file]}
    output=$( timeout -k 1 -s TERM $timeout io-client -u ${files[file]} | tail -n1 )
    count=$( timeout -k 1 -s TERM $timeout io-client -u ${files[file]} | wc -l )
    echo "file/output=\"$output\""
    echo "file/count=\"$count\""
    rm -f ${files[file]}
}

function test_pipe
{
    files[pipe]=$dir/${prefix}_pipe
    local message="pipe_message1\npipe_message2"
    rm -f ${files[pipe]}
    mkfifo ${files[pipe]}
    echo -e "$message" > ${files[pipe]} &
    output=$( timeout -k 1 -s TERM $timeout io-client -u ${files[pipe]} )
    echo "pipe/output=\"$output\""
    rm -f ${files[pipe]}
}

port=$( find_free_port )
if [[ -z "$port" ]]; then echo "failed to find a free port" >&2; exit 1; fi

test_tcp
test_udp
test_socket
test_zmq_socket
test_zmq_tcp
test_file
test_pipe
