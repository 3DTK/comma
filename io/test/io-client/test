#!/bin/bash

timeout=1
port=9123
socket=/tmp/io-client_input_socket
file=/tmp/io-client_input_file
pipe=/tmp/io-client_input_pipe

if netstat -ln | grep $port &>/dev/null; then echo "port $port is not available (remedy: free this port or change port number in the test)" >&2; exit 1; fi

function wait_for_condition
{
    reps=10
    dt=0.1
    for(( i=0; i<$reps; i++ )); do
        eval "$1" && return 0 || sleep $dt
    done
    echo "condition '$1' has not been satisfied in the alloted $( bc -l <<< "$reps*$dt" ) seconds" >&2
    return 1
}

function bye
{
    rm -f $socket $file $pipe
    kill -9 $tcp_pid $udp_pid $local_pid &>/dev/null
    exit 1
}

trap bye INT TERM HUP

echo -e "tcp_message1\ntcp_message2" | socat -u - tcp-listen:$port,reuseaddr & tcp_pid=$!
output=$( wait_for_condition "netstat -ltn | grep $port &>/dev/null" && timeout -k 1 -s TERM $timeout io-client -u tcp:localhost:$port | tail -n1 )
echo "tcp/output=\"$output\""
kill $tcp_pid &>/dev/null
wait $tcp_pid

{ wait_for_condition "netstat -lun | grep $port &>/dev/null" && echo -e "udp_message1\nudp_message2" | socat - udp-sendto:localhost:$port; } & udp_pid=$!
output=$( timeout -k 1 -s TERM $timeout io-client -u udp:$port | tail -n1 )
echo "udp/output=\"$output\""
wait $udp_pid

rm -f $socket
echo -e "local_message1\nlocal_message2" | socat -u - unix-listen:$socket & local_pid=$!
output=$( wait_for_condition "test -S $socket" && timeout -k 1 -s TERM $timeout io-client -u local:$socket | tail -n1 )
echo "local/output=\"$output\""
rm -f $socket
kill $local_pid &>/dev/null
wait $local_pid

rm -f $file
echo -e "file_message1\nfile_message2" > $file
output=$( timeout -k 1 -s TERM $timeout io-client -u $file | tail -n1 )
count=$( timeout -k 1 -s TERM $timeout io-client -u $file | wc -l )
echo "file/output=\"$output\""
echo "file/count=\"$count\""
rm -f $file

rm -f $pipe
mkfifo $pipe
echo -e "pipe_message1\npipe_message2" > $pipe &
output=$( timeout -k 1 -s TERM $timeout io-client -u $pipe )
echo "pipe/output=\"$output\""
rm -f $pipe
