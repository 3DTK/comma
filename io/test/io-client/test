#!/bin/bash

port=9123
timeout=1
dir=/tmp
prefix=io-client
declare -A pids
declare -A files

function bye
{
    pkill -P $$
    rm -f ${files[@]}
    kill -9 ${pids[@]} &>/dev/null
    exit 1
}

trap bye INT TERM HUP

function wait_for_success
{
    reps=10
    dt=0.1
    for(( i=0; i<$reps; i++ )); do
        eval "$1" && return 0 || sleep $dt
    done
    echo "condition '$1' has not been satisfied in the alloted $( bc -l <<< "$reps*$dt" ) seconds" >&2
    return 1
}

function test_tcp
{
    local message="tcp_message1\ntcp_message2"
    local condition="netstat -ltn | grep $port &>/dev/null"
    echo -e "$message" | socat -u - tcp-listen:$port,reuseaddr & pids[tcp]=$!
    output=$( wait_for_success "$condition" && timeout -k 1 -s TERM $timeout io-client -u tcp:localhost:$port | tail -n1 )
    echo "tcp/output=\"$output\""
    kill ${pids[tcp]} &>/dev/null
    wait ${pids[tcp]}
}

function test_udp
{
    local message="udp_message1\nudp_message2"
    local condition="netstat -lun | grep $port &>/dev/null"
    wait_for_success "$condition" && echo -e "$message" | socat - udp-sendto:localhost:$port & pids[udp]=$!
    output=$( timeout -k 1 -s TERM $timeout io-client -u udp:$port | tail -n1 )
    echo "udp/output=\"$output\""
    kill ${pids[udp]} &>/dev/null
    wait ${pids[udp]}
}

function test_socket
{
    files[socket]=$dir/${prefix}_socket
    local message="local_message1\nlocal_message2"
    local condition="test -S ${files[socket]}"
    rm -f ${files[socket]}
    echo -e "$message" | socat -u - unix-listen:${files[socket]} & pids[socket]=$!
    output=$( wait_for_success "$condition" && timeout -k 1 -s TERM $timeout io-client -u local:${files[socket]} | tail -n1 )
    echo "socket/output=\"$output\""
    kill ${pids[socket]} &>/dev/null
    wait ${pids[socket]}
    rm -f ${files[socket]}
}

function test_zmq_socket
{
    files[zmq_socket]=$dir/${prefix}_zmq_socket
    local message="zmq_local_message1\nzmq_local_message2"
    local condition="test -S ${files[zmq_socket]}"
    rm -f ${files[zmq_socket]}
    {
        exec 3> >( zero-cat --publish ipc://${files[zmq_socket]} )
        sleep 0.5
        echo -e "$message" >&3
    } &
    output=$( timeout -k 1 -s TERM $timeout io-client -u zmq-local:${files[zmq_socket]} | tail -n1 )
    echo "zmq_socket/output=\"$output\""
    kill ${pids[zmq_socket]} &>/dev/null
    wait ${pids[zmq_socket]}
    rm -f ${files[zmq_socket]}
}

function test_file
{
    files[file]=$dir/${prefix}_file
    local message="file_message1\nfile_message2"
    echo -e "$message" > ${files[file]}
    output=$( timeout -k 1 -s TERM $timeout io-client -u ${files[file]} | tail -n1 )
    count=$( timeout -k 1 -s TERM $timeout io-client -u ${files[file]} | wc -l )
    echo "file/output=\"$output\""
    echo "file/count=\"$count\""
    rm -f ${files[file]}
}

function test_pipe
{
    files[pipe]=$dir/${prefix}_pipe
    local message="pipe_message1\npipe_message2"
    rm -f ${files[pipe]}
    mkfifo ${files[pipe]}
    echo -e "$message" > ${files[pipe]} &
    output=$( timeout -k 1 -s TERM $timeout io-client -u ${files[pipe]} )
    echo "pipe/output=\"$output\""
    rm -f ${files[pipe]}
}

if netstat -ln | grep $port &>/dev/null; then echo "port $port is not available (remedy: free this port or change port number in the test)" >&2; exit 1; fi

test_tcp
test_udp
test_socket
test_zmq_socket
test_file
test_pipe
