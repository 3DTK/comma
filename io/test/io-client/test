#!/bin/bash

port=9123
timeout=1

if netstat -ln | grep $port &>/dev/null; then echo "port $port is not available (remedy: free this port or change port number in the test)" >&2; exit 1; fi

function wait
{
    reps=10
    dt=0.1
    for(( i=0; i<$reps; i++ )); do
        eval "$1" && return 0 || sleep $dt
    done
    echo "condition $1 has not been satisfied in the alloted $(( reps * dt )) seconds" >&2
    return 1
}

echo -e "tcp_message1\ntcp_message2" | socat -u - tcp-listen:$port,reuseaddr &
output=$( wait "netstat -ltn | grep $port &>/dev/null" && timeout -k 1 -s TERM $timeout io-client -u tcp:localhost:$port | tail -n1 )
echo "tcp/output=\"$output\""

{ wait "netstat -lun | grep $port &>/dev/null" && echo -e "udp_message1\nudp_message2" | socat - udp-sendto:localhost:$port; } &
output=$( timeout -k 1 -s TERM $timeout io-client -u udp:$port | tail -n1 )
echo "udp/output=\"$output\""

socket=/tmp/input_socket
rm -f $socket
echo -e "local_message1\nlocal_message2" | socat -u - unix-listen:$socket &
output=$( wait "test -S $socket" && timeout -k 1 -s TERM $timeout io-client -u local:$socket | tail -n1 )
echo "local/output=\"$output\""
rm -f $socket

file=input_file
rm -f $file
echo -e "file_message1\nfile_message2" > $file
output=$( timeout -k 1 -s TERM $timeout io-client -u $file | tail -n1 )
count=$( timeout -k 1 -s TERM $timeout io-client -u $file | wc -l )
echo "file/output=\"$output\""
echo "file/count=\"$count\""
rm -f $file

pipe=input_pipe
rm -f $pipe
mkfifo $pipe
echo -e "pipe_message1\npipe_message2" > $pipe &
output=$( timeout -k 1 -s TERM $timeout io-client -u $pipe )
echo "pipe/output=\"$output\""
rm -f $pipe
