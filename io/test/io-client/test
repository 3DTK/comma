#!/bin/bash

timeout=1
dir=/tmp
prefix=io-client
declare -A pids
declare -A files

function bye
{
    pkill -P $$
    rm -f ${files[@]}
    kill -9 ${pids[@]} &>/dev/null
    exit 1
}

trap bye INT TERM HUP

function find_free_port
{
    local -i start=${1:-1024}
    local -i end=${2:-65535}
    if (( start < 1024 )); then echo "$FUNCNAME: expected start port to be from 1024 to 65535, got $start" >&2; return; fi
    if (( end > 65535 )); then echo "$FUNCNAME: expected end port to be from 1024 to 65535, got $end" >&2; return; fi
    if (( start > end )); then echo "$FUNCNAME: expected start <= end, got start = $start and end = $end" >&2; return; fi
    for(( port=start; port <= end; port++ )); do
        if ! netstat -ltun | grep $port &>/dev/null; then echo $port && return; fi
    done
}

function wait_for_success
{
    reps=10
    dt=0.1
    for(( i=0; i<$reps; i++ )); do
        eval "$1" && return 0 || sleep $dt
    done
    echo "condition '$1' has not been satisfied in the alloted $( bc -l <<< "$reps*$dt" ) seconds" >&2
    return 1
}

function test_tcp
{
    local message="$1"
    echo -e "$message" | socat -u - tcp-listen:$port,reuseaddr & pids[tcp]=$!
    output=$( wait_for_success "netstat -ltn | grep $port &>/dev/null" && timeout -k 1 -s TERM $timeout io-client -u tcp:localhost:$port | tail -n1 )
    echo "tcp/output=\"$output\""
    kill ${pids[tcp]} &>/dev/null
    wait ${pids[tcp]}
}

function test_udp
{
    local message="$1"
    wait_for_success "netstat -lun | grep $port &>/dev/null" && echo -e "$message" | socat - udp-sendto:localhost:$port & pids[udp]=$!
    output=$( timeout -k 1 -s TERM $timeout io-client -u udp:$port | tail -n1 )
    echo "udp/output=\"$output\""
    kill ${pids[udp]} &>/dev/null
    wait ${pids[udp]}
}

function test_socket
{
    local message="$1"
    local socket=$dir/${prefix}_socket
    files[socket]=$socket
    rm -f $socket
    echo -e "$message" | socat -u - unix-listen:$socket & pids[socket]=$!
    output=$( wait_for_success "test -S $socket" && timeout -k 1 -s TERM $timeout io-client -u local:$socket | tail -n1 )
    echo "socket/output=\"$output\""
    kill ${pids[socket]} &>/dev/null
    wait ${pids[socket]}
    rm -f $socket
}

function test_zmq_socket
{
    local message="$1"
    local socket=$dir/${prefix}_zmq_socket
    files[zmq_socket]=$socket
    rm -f $socket
    exec 3> >( zero-cat --publish ipc://$socket ) && wait_for_success "test -S $socket" && sleep 0.1 && echo -e "$message" >&3 && exec 3<&- &
    output=$( timeout -k 1 -s TERM $timeout io-client -u zmq-local:$socket | tail -n1 )
    echo "zmq_socket/output=\"$output\""
    rm -f $socket
}

function test_zmq_tcp
{
    # todo
    echo "$FUNCNAME is not implemented" >&2
}

function test_file
{
    local message="$1"
    local file=$dir/${prefix}_file
    files[file]=$file
    echo -e "$message" > $file
    output=$( timeout -k 1 -s TERM $timeout io-client -u $file | tail -n1 )
    count=$( timeout -k 1 -s TERM $timeout io-client -u $file | wc -l )
    echo "file/output=\"$output\""
    echo "file/count=\"$count\""
    rm -f $file
}

function test_pipe
{
    local message="$1"
    local pipe=$dir/${prefix}_pipe
    files[pipe]=$pipe
    rm -f $pipe
    mkfifo $pipe
    echo -e "$message" > $pipe &
    output=$( timeout -k 1 -s TERM $timeout io-client -u $pipe )
    echo "pipe/output=\"$output\""
    rm -f $pipe
}

port=$( find_free_port )
if [[ -z "$port" ]]; then echo "failed to find a free port" >&2; exit 1; fi

test_tcp "tcp_message1\ntcp_message2"
test_udp "udp_message1\nudp_message2"
test_socket "socket_message1\nsocket_message2"
test_zmq_socket "zmq_socket_message1\nzmq_socket_message2"
test_zmq_tcp
test_file "file_message1\nfile_message2"
test_pipe "pipe_message1\npipe_message2"
