#!/bin/bash

name=$( basename $0 )

simple_usage()
{
    echo "Usage: $name [-h|--help] -t|--table=<table name> -f|--fields=<input fields> [--table-fields=<table fields>] [--convert-times]" >&2
    if [[ $# != 0 ]]; then exit $1; fi
}

usage()
{
    simple_usage
    cat >&2 <<EOF

Converts csv to SQL "insert" statements.

Options:
    -h|--help           Show this help
    -t|--table-name=    Table name to use in SQL statements
    -f|--fields=        Input fields (comma separated)
    --table-fields=     Fields to insert into the table (by default, same as input fields)
    --convert-times     Automatically convert times from format "YYYYMMDDThhmmss" to "YYYY-MM-DD hh:mm:ss"

Example:
    echo 0,1,hi there,20131231T055932,25 | $name -t=fred -f=ignored,id,str,time,ignored2 --table-fields=id,time,str --convert-times

Output:
    insert into \`fred\` (\`id\`,\`time\`,\`str\`) values ('1','2013-12-31 05:59:32','hi there');

EOF
    if [[ $# != 0 ]]; then exit $1; fi
}

function status_ok()
{
    [[ ! "${PIPESTATUS[@]}" =~ [1-9] ]]
}

# arguments: (optional) <exit code>
function bye()
{
    if [[ -z $1 ]] ; then exit 1 ; else exit $1; fi
}

# arguments are an error message to print
function die()
{
    echo "$name: $*" >&2
    bye 1
}

# arguments: <comma separated fields (corresponding to $output_fields)>
function create_insert_statement()
{
    echo "insert into \`$table_name\` ($table_columns) values ($( echo $* | sed "s/'/\\\'/g; s/[^,]*/'&'/g" ));"
}

# input: comma separated fields
# output: same as input, with time fields like "20140118T012345" converted to the form "2014-01-18 01:23:45"
function convert_time_fields()
{
    if (( convert_times_option )); then
        awk -F, '
        BEGIN { OFS = ","; }
        { for (f = 1;f <= NF;f++)
        if ($f ~ "^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]T[0-9][0-9][0-9][0-9][0-9][0-9]$") \
        { $f = substr($f, 1, 4) "-" substr($f, 5, 2) "-" substr($f, 7, 2) " " substr($f, 10, 2) ":" substr($f, 12, 2) ":" substr($f, 14, 2); }
        print $0;
        }
        '
    else
        cat
    fi
}

trap 'bye 1' SIGHUP SIGTERM SIGPIPE SIGINT

if [[ $# == 0 ]]; then simple_usage 1; fi
convert_times_option=0

while [[ $# -gt 0 ]]; do
    arg="${1#*=}"
    case "$1" in
        -h|--help)          usage 0;;
        -t=*|--table=*)     table_name=$arg;;
        -f=*|--fields=*)    input_fields=$arg;;
        --table-fields=*)   output_fields=$arg;;
        --convert-times)    convert_times_option=1;;
        -*)                 echo "$name: unrecognized option '$1'" >&2; exit 1;;
        *)                  echo "$name: unexpected argument '$1'" >&2; exit 1;;
    esac
    shift
done

if [[ -z "$table_name" ]]; then die "missing required argument --table-name"; fi
if [[ -z "$input_fields" ]]; then die "missing required argument --fields"; fi
if [[ -z "$output_fields" ]]; then output_fields=$input_fields; fi

# test if all fields are present
echo | csv-shuffle --fields=$input_fields --output-fields=$output_fields > /dev/null 2>&1
if [[ $? != 0 ]]; then die "table fields do not match input fields"; fi

# enclose column names in backquotes
table_columns=$( echo $output_fields | sed 's/\<[^,]*\>/`&`/g' )

while read input_line; do
    create_insert_statement \
        $( echo $input_line \
           | csv-shuffle --fields=$input_fields --output-fields=$output_fields \
           | convert_time_fields )
done

bye 0
