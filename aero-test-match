#!/bin/bash

name=$( basename $0 )

function simple_usage()
{
    echo "Usage: $name [-h|--help] [-v|--variables=<file>] <expected-values-file>" >&2
    if [[ $# != 0 ]]; then exit $1; fi
}

function usage()
{
    simple_usage
    cat >&2 <<EOF

Verify input against expected values.

By default, variable values are read from stdin. Input consists of lines in the form "path=value".
Paths may contain array indexes, e.g. abc/def[10]/xyz. Quotes around values are optional (even if
the value contains spaces).

The <expected-values-file> contains one boolean expression per line, referring to the path values.

Examples:

some_value = 5.23
flight/weight > some/other/weight + 28000
abc/def[10]/xyz != "YSSY"

EOF
    if [[ $# != 0 ]]; then exit $1; fi
}

if [[ $# == 0 ]]; then simple_usage 1; fi

variables=
expr_file=

while [[ $# -gt 0 ]]; do
    arg="${1#*=}"
    case "$1" in
        -h|--help)          usage 0;;
        -v=*|--variables=*) variables=$arg;;
        -*)                 echo "$name: unrecognized option '$1'" >&2; exit 1;;
        *)                  if [[ -z "$expr_file" ]]; then expr_file=$arg
                            else echo "$name: unexpected argument '$1'" >&2; exit 1; fi;;
    esac
    shift
done

if [[ -z "$expr_file" ]]; then echo "$name: missing required argument <expected-values-file>" >&2; exit 1; fi

# if the variables file name is known, pass it to name-value-eval, since it can appear in some error messages
if [[ -z "$variables" ]]; then name-value-eval --test "$expr_file"
else name-value-eval --test "$expr_file" --variables="$variables"; fi

