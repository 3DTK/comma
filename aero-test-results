#!/bin/bash

name=$( basename $0 )

# defaults can be overridden through config
db_host="129.78.214.114"
db_port="3306"
db_user="jobq_submit"
db_pwd="bReWAca4rUJu"
db_name="qdata"
all_db_vars="db_host,db_port,db_user,db_pwd,db_name"

# aero-test-[sql-]util are in the same folder as this script
source $( which comma-application-util )
source $( dirname $0 )/aero-test-util
source $( dirname $0 )/aero-test-sql-util

function usage()
{
    cat <<EOF >&2
Usage: $name [<batch id>] [-f|--force] [-v|--verbose] [--path=<qstorage dir>]

Check the results of tests that were run using aero-test-submit.
If <batch id> is not specified, the latest id is used, but the user is asked to verify it first.

Options:

    -h|--help       Show this help
    -f|--force      Force the results to be checked even if all jobs have not yet completed
    -v|--verbose    Print information about successful tests as well as failed ones
    --config=       Provide a configuration file to override default parameters of SQL database
    --path=         Qstorage directory (e.g. "/mnt/q-storage", "/var/qantas/data"; default: check for both)

EOF
}

function verify_batch_id()
{
    if [[ -z "$batch_id" ]]; then
        batch_id=$( $sql_command "select max(batchId) from JobQ" | tail -1 )
        # since this is a long running command, verify the batch id instead of automatically using the latest one
        echo -n "Batch id $batch_id? (y or n) "
        read answer
        case $answer in
            y*|Y*) ;;
            *) echo "Aborting."; exit 0
        esac
    else
        count=$( $sql_command "select count(*) from JobQ where batchId = $batch_id" | tail -1 )
        if [[ $count == 0 ]]; then echo "No jobs found with batch id $batch_id"; exit 1; fi
    fi
}

function determine_path_prefix()
{
    if [[ -z "$path_prefix" ]]; then
        # test machines such as afps-001 use "/var/qantas/data" instead of "/mnt/q-storage";
        # check which prefix is required
        if [[ -d "/mnt/q-storage" ]]; then path_prefix="/mnt/q-storage"
        elif [[ -d "/var/qantas/data" ]]; then path_prefix="/var/qantas/data"
        else
            echo "$name: error: cannot find either \"/mnt/q-storage\" or \"/var/qantas/data\"; aborting." >&2
            exit 1
        fi
    fi
}

# copy input to output, and return failure (1) if there was any output
# Argument: description of test (job id and path)
function fail_on_output()
{
    local description=$1
    output="$( awk 'NR == 1 { print "Failed: '"$description"'"; } { print $0; }' )"
    if [[ -z "$output" ]]; then
        if (( verbose )); then echo "Passed: $description"; fi
        return 0
    fi
    echo "$output"
    echo
    return 1

    #if awk 'NR == 1 { print "'"$1"'"; } { print $0; any = 1; } END { if (any) printf " \n"; }' | grep "."
    #then return 1; else return 0; fi
}

# arguments: <job id> <flight plan directory> <test directory>
function check_results()
{
    local hardcoded_prefix="/var/qantas/data/"    # the prefix used by aero-test-submit
    local job_id=$1
    local plan_dir=$2
    local test_dir=$3

    # check if the prefix of $plan_dir needs to be changed (e.g. from "/var/qantas/data" to "/mnt/q-storage")
    plan_dir=$( echo $plan_dir | awk '
        BEGIN { prefix = "'"$path_prefix"'"; }
        { if (substr($0, 1, length(prefix)) == prefix) { print $0; } \
          else print prefix "/" substr($0, length("'$hardcoded_prefix'") + 1); } ' | sed 's/\/\//\//g' )
    
    local actual="$plan_dir/fixm-prototype.path-value"
    local expected="$test_dir/expected"

    if [[ ! -f "$actual" ]]; then echo "Error (job $job_id): result file not found: $actual"; return 1; fi
    if [[ ! -f "$expected" ]]; then echo "Error (job $job_id): test file not found: $expected"; return 1; fi

    if aero-test-match -v="$actual" "$expected" 2>&1 | fail_on_output "job $job_id $test_dir"; then
        (( ++success_count ))
    fi 
}

path_prefix=
batch_id=
force=0
verbose=0
config_file=""

for arg in "$@"; do
    case $arg in
        -h|--help)    usage; exit 0;;
        -f|--force)   force=1;;
        -v|--verbose) verbose=1;;
        --path=*)     path_prefix=${arg#*=};;
        --config=*)   config_file=${arg#*=};;
        -*)           echo "$name: unknown option '$arg'" >&2; exit 1;;
        *)            if [[ -z "$batch_id" ]]; then batch_id=$arg
                      else echo "$name: unexpected argument '$arg'" >&2; exit 1; fi;;
    esac
done

if [ -n "$config_file" ] ; then sql_read_config "$config_file" "$all_db_vars" || exit 1 ; fi
sql_command=$( sql_get_command )

determine_path_prefix
verify_batch_id

unfinished_count=$( $sql_command "select count(*) from JobQ where batchId = $batch_id and not (status = 'DONE' or status = 'ERROR')" | tail -1 )

if [[ "$unfinished_count" != 0 && $force == 0 ]]; then
    echo "Still waiting for $unfinished_count job(s) (use option --force to check finished jobs only)"
    exit 1
fi

unfinished_msg=
if [[ $unfinished_count != 0 ]]; then unfinished_msg=" ($unfinished_count jobs still running)"; fi
plan_failed_count=$( $sql_command "select count(*) from JobQ where batchId = $batch_id and status = 'ERROR'" | tail -1 )

if [[ "$plan_failed_count" != 0 ]]; then
    echo "Flight planning failed for $plan_failed_count test(s):"
    $sql_command "select stdin from JobQ where batchId = $batch_id and status = 'ERROR'" |
        awk 'NR == 1 { next; }  # skip header line
             /^# path:/ { pos1 = index($0, "/"); pos2 = index($0, "\\n"); print substr($0, pos1, pos2 - pos1); next; }
             !warned { print "(warning: cannot get path for some of the jobs in batch '$batch_id')"; warned = 1; }'
fi

plan_completed_count=$( $sql_command "select count(*) from JobQ where batchId = $batch_id and status = 'DONE'" | tail -1 )
success_count=0

if [[ "$plan_completed_count" != 0 ]]; then
    echo "Checking $plan_completed_count tests ..."
    # input is like: "123 /var/qantas/data/... # path: /home/qantas/acceptance/..."
    while read job_id flight_plan_dir comment_char path_word test_dir; do
        if [[ "$comment_char" != "#" || "$path_word" != "path:" ]]; then echo "(warning: cannot get path for job $job_id)"
        else check_results $job_id "$flight_plan_dir" "$test_dir"; fi
    done < <( $sql_command "select jobId, outputPath, stdin from JobQ where batchId = $batch_id and status = 'DONE'" |
              awk 'NR != 1 { print $0; }' | sed 's/\\n.*//g' )

    echo "$success_count out of $(( plan_completed_count + plan_failed_count )) tests passed$unfinished_msg."
else
    echo "No successful plans$unfinished_msg."
fi

