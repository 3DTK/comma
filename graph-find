#!/bin/bash

name=$( basename $0 )

simple_usage()
{
    echo "Usage: $name [-h|--help] <edge-file> <from> <to> [-v|--vertices=<vertex-file>] [-vf|--vfields=<vfields>] [-f|--fields=<fields>] [-e|--edges] [--rev] [-b|--bidirectional] [--dfs|--bfs|--shortest] [--reachable|-r] [-q|--quiet]" >&2
}

usage()
{
    simple_usage
    cat >&2 <<EOF

Performs a graph operation such as finding the shortest path between two vertices.

Arguments:

  <edge-file>          Graph file with lines in the form: <from-id>,<to-id> (ids may be any string)
                       plus an optional ,<weight> for option --bfs|--shortest.
                       Use "-" for standard input.

  <from>               Start vertex id.

  <to>                 End vertex id (optional with --reachable option).

  -v|--vertices        (Optional) vertex file; if present, output includes vertex lat,lon as well
                       as vertex id. Default fields are: latitude,longitude,,id.

  -vf|--vfields        Specify comma separated fields in vertex file, using the names "id",
                       "latitude" and "longitude". For example: --vfields=latitude,longitude,,id

  -f=<fields>          Specify comma separated fields in edge file, using the names "from",
                       "to" and (optional) "weight". For example: --fields=to,from,,,weight.

  -e|--edges           Output pairs of ids (id1,id2) instead of individual ids.
                       For "path" search (--bfs, --dfs), outputs each edge on the path.
                       For "reachable" search (-r), outputs all reachable edges instead of vertices.
                       With a vertices file (-f), outputs lat1,lon1,lat2,lon2,id1,id2 for each edge.

  --rev[erse]          Short for "--fields=from,to" (but edges are output in to,from order).

  -b|--bidirectional   Implicitly add edges in the reverse direction.

  --dfs (default)      Depth first search: output the first path found between <from> and <to>.

  --bfs|               Breadth first search: output the shortest path found. If no <weight>
  --shortest           field is specified, all edges are assigned the same weight.

  -r|--reachable       Output all of the vertices which can be reached by <from>. The <to> field
                       is not required, but if more than one vertex is specified, all of the
                       vertices that can be reached by any of them are output.

  -q|--quiet           Suppress normal output (just set the exit code).

Output:

    If a path is found, all of the vertices are output on a single line, and the exit code is 0.
    If no path is found, a message is printed to stderr and the exit code is 2.
    If there is any other error (e.g. file not found), the exit code is 1.

Examples:

    $name mesh.csv 12 100
    
        Find a path from vertex 12 to vertex 100 in mesh.csv

    $name mesh.csv --fields=from,to 100 12
    
        As above, but in reverse.

    $name - --fields=,,to,from,,weight --shortest YSSY KLAX

        Reading from standard input, and using the 3rd and 4th fields as ids and the 6th field
        as an edge weight, find the shortest path from vertex "YSSY" to vertex "KLAX".

    $name data.csv --reachable 10 12 37

        Output all vertices reachable from vertices 10, 12 or 37.

EOF
}

if [[ $# == 0 ]]; then
    simple_usage
    exit 1
fi

echo "$name: called $name $*" >&2

file=
vlist=()
fields=
vertices=
vfields=
bidir=0
bfs=0
reachable=0
output_edges=0
reverse_edges=0
quiet=0

while [[ $# -gt 0 ]]; do
    case "$1" in
    -h|--help)
        usage
        exit 0
        ;;
    -f=*|--fields=*)
        fields="${1#*=}"
        ;;
    -b|--bidirectional)
        bidir=1
        ;;
    --dfs)
        bfs=0
        ;;
    --bfs|--shortest)
        bfs=1
        ;;
    -r|--reachable)
        reachable=1
        ;;
    -v=*|--vertices=*)
        vertices="${1#*=}"
        ;;
    -vf=*|--vfields=*|--vertex-fields=*|--vertices-fields=*)
        vfields="${1#*=}"
        ;;
    --rev|--reverse|--reversed)
        fields=to,from
        reverse_edges=1
        ;;
    -e|--edges)
        output_edges=1
        ;;
    -q|--quiet)
        quiet=1
        ;;
    -*)
        echo "$name: unrecognized option '$1'" >&2
        exit 1
        ;;
    *)  if [[ -z "$file" ]]; then
            file="$1"
        else
            vlist+=( "$1" )
        fi
    esac
    shift
done

if [[ -z "$file" ]]; then
    echo "$name: filename required (use \"-\" for standard input)" >&2
    exit 1
fi

if [[ "$file" == "-" ]]; then
    file=
else
    if [[ ! -f "$file" ]]; then
        echo "$name: cannot open '$file'" >&2
        exit 1
    fi
fi

if [[ "$reachable" == 1 ]]; then
    if [[ ${#vlist[@]} == 0 ]]; then
        echo "$name: at least one vertex id must be specified with --reachable" >&2
        exit 1
    fi
    reachable_list=$( echo ${vlist[@]} )
else
    if [[ ${#vlist[@]} != 2 ]]; then
        echo "$name: \"from\" and \"to\" vertex ids must be specified" >&2
        exit 1
    else
        from_id=${vlist[0]}
        to_id=${vlist[1]}
    fi
fi

get_graph()
{
    if [[ $bidir == 1 ]]; then
        cmd=( awk -F, '{ print; print $2 "," $1 "," $3; }' $file )
    else
        cmd=( cat $file )
    fi

    if [[ -n "$fields" ]]; then
        if [[ "$fields" = *weight* ]]; then
            out_fields=from,to,weight
        else
            out_fields=from,to
        fi
        "${cmd[@]}" | csv-shuffle --fields="$fields" --output-fields="$out_fields"
    else
        "${cmd[@]}"
    fi
}

if [[ "$reachable" == 1 ]]; then
    result=$( get_graph | awk -F, '
{
    from = $1 "";   # need to treat as a string, not a number
    to = $2 "";
    edge[from,++num_from[from]] = to;
    is_vertex[from] = 1;
    is_vertex[to] = 1;
}

END \
{
    output_edges = '"$output_edges"';
    num = split("'"$reachable_list"'", vlist, " ");
    for (f = 1;f <= num;f++)
    {
        if (is_vertex[vlist[f]] != 1)
        {
            print "Vertex \"" vlist[f] "\" does not appear in any edges of the graph" | "cat 1>&2";
            err = 1;
        }
        stack[f - 1] = vlist[f]; vis[stack[f - 1]] = 1;
    }
    if (err) exit;

    while (num > 0)
    {
        val = stack[--num];
        if (!output_edges) { printf sep val; sep = " "; }

        for (e = 1;e <= num_from[val];e++)
        {
            val2 = edge[val,e];
            if (output_edges) { print sep val "," val2; sep = " "; }

            if (vis[val2] != 1)
            {
                stack[num] = val2;
                vis[val2] = 1;
                num++;
            }
        }
    }

    printf "\n";
}
' )
elif [[ "$bfs" == 1 ]]; then
    if [[ "$fields" = *weight* ]]; then
        echo "$name: breadth first search with variable weights is not implemented yet" >&2
        exit 1
    else
        # breadth first search, constant weight
        result=$( get_graph | awk -F, '
{
    from = $1 "";   # need to treat as a string, not a number
    to = $2 "";
    edge[from,++num_from[from]] = to;
}

END \
{
    output_edges = '"$output_edges"';
    dest = "'"$to_id"'";
    queue[0] = "'"$from_id"'";
    vis[queue[0]] = 1;
    if (!output_edges) { path[0] = queue[0]; }
    q_front = 0;
    q_back = 0;

    while (q_front >= q_back)
    {
        val = queue[q_back];
        p = path[q_back];
        delete queue[q_back];
        delete path[q_back++];

        if (val == dest) { print p; exit; }

        for (e = 1;e <= num_from[val];e++)
        {
            val2 = edge[val,e];
            if (vis[val2] != 1)
            {
                queue[++q_front] = val2;
                if (output_edges) { path[q_front] = p sep val "," val2; sep = " "; } \
                else { path[q_front] = p " " val2; }
                vis[val2] = 1;
            }
        }
    }
}
' )
    fi
else
    # depth first search
    result=$( get_graph | awk -F, '
{
    from = $1 "";   # need to treat as a string, not a number
    to = $2 "";
    edge[from,++num_from[from]] = to;
}

END \
{
    output_edges = '"$output_edges"';
    dest = "'"$to_id"'";
    stack[0] = "'"$from_id"'";
    vis[stack[0]] = 1;
    if (!output_edges) { path[0] = stack[0]; }
    num = 1;

    while (num > 0)
    {
        val = stack[--num];
        p = path[num];

        if (val == dest) { print p; exit; }

        for (e = 1;e <= num_from[val];e++)
        {
            val2 = edge[val,e];
            if (vis[val2] != 1)
            {
                stack[num] = val2;
                if (output_edges) { path[num] = p sep val "," val2; sep = " "; } \
                else { path[num] = p " " val2; }
                vis[val2] = 1;
                num++;
            }
        }
    }
}
' )
fi

if [[ -z "$result" ]]; then
    if (( !quiet )); then
        if [[ $reachable == 1 ]]; then
            if [[ $output_edges == 1 ]]; then
                echo "No reachable edges" >&2
            else
                echo "No reachable vertices" >&2
            fi
        else
            echo "No path found" >&2
        fi
    fi
    exit 2
else
    if (( quiet )); then exit 0; fi
    if [[ $output_edges == 1 && $reverse_edges == 1 ]]; then
        result=$( echo $result | fmt -1 | awk -F, '{ print $2 "," $1; }' )
    fi

    if [[ -z "$vertices" ]]; then
        echo $result
    else
        if [[ -z "$vfields" ]]; then
            cmd=( cat )
        else
            cmd=( csv-shuffle --fields="$vfields" --output-fields="latitude,longitude,,id" )
        fi

        ( cat "$vertices" | "${cmd[@]}"; echo "---"; echo $result | fmt -1 ) | awk -F, '
        /^---$/ { z = 1; next; }
        z != 1 { pos[$4 ""] = $1 "," $2; next; }
        {
            ignore = 0;
            v1 = $1 "";
            v2 = $2 "";
            if (!(v1 in pos)) { print "Vertex " v1 " not found" | "cat 1>&2"; ignore = 1; }
            if (NF == 2 && !(v2 in pos)) { print "Vertex " v2 " not found" | "cat 1>&2"; ignore = 1; }
            if (!ignore)
            {
                printf pos[v1];
                if (NF == 2) { printf "," pos[v2]; }
                printf "," v1;
                if (NF == 2) { printf "," v2; }
                printf "\n";
            }
        }'
    fi
fi

