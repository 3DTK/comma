#!/bin/bash

name=$( basename $0 )

submit_time=$( date --utc "+%Y%m%dT%H%M%S" )
output_base_dir="/var/qantas/data/log/gui/acceptance"
user_name="acceptance"
# TODO: change to "prod" when ready for release
build_to_use="bleeding"   # "prod", "test" or "bleeding"
task_priority=3
db_host="129.78.214.114"
db_port="3306"
db_user="jobq_submit"
db_pwd="bReWAca4rUJu"
db_name="qdata"
sql_command="mysql -h $db_host -P $db_port -u $db_user -p$db_pwd $db_name -e "

# aero-test-util is in the same folder as this script
source $( dirname $0 )/aero-test-util

function usage_()
{
    echo "Usage: $name [-h|--help]" >&2
    echo >&2
    echo "Search for subdirectories containing \"expected\" (and \"input\") files and submit these tests to the job queue" >&2
    echo >&2
}

# arguments: <filename> <path plan to get>, e.g. "input" "plan/from"
function extract_value()
{
    local result=$( grep "^ *$2=" "$1" | sed 's/^[^=]*=//g' )
    if [[ -z "$result" ]]; then echo "$name: missing \"$2\" in $( readlink -e $1 )" >&2; return 1; fi
    echo $result
}

# argument: <input file> <test directory> <batch id> <sequence number>
function create_insert_statement()
{
    local input_file=$1
    local test_dir=$2
    local batch_id=$3
    local seq_num=$4

    local input="# path: $test_dir\\n"
    input+=$( cat "$input_file" | sed 's/$/\\/g' | tr '\n' 'n' )   # all one line, newlines replaced with a literal "\n"
    local plan_from=$( extract_value "$input_file" "plan/from" )
    local plan_to=$( extract_value "$input_file" "plan/to" )
    local plan_time=$( extract_value "$input_file" "plan/departure_time" )
    if [[ -z "$plan_from" || -z "$plan_to" || -z "$plan_time" ]]; then return 1; fi  # error message already printed
    local output_path="$output_base_dir/${submit_time}_${batch_id}_${seq_num}_${plan_from}-${plan_to}"

    # time format is like: "2014-01-23 12:34:56"
    local time_in_sql_format=$( echo $plan_time | awk '{ print substr($1, 1, 4) "-"  substr($1, 5, 2) "-" substr($1, 7, 2) " " substr($1, 10, 2) ":" substr($1, 12, 2) ":" substr($1, 14, 2); }' )

    echo "INSERT INTO JobQ (submitTime, batchId, task, JobQ.from, JobQ.to, takeoffTime, username, stdin, outputPath, build, priority)
VALUES (now(), $batch_id, 'BUILDPLAN', '$plan_from', '$plan_to', '$time_in_sql_format', '$user_name', '$input', '$output_path',
'$build_to_use', $task_priority)"
}

for arg in "$@" ; do
    if [[ "$arg" == "--help" || "$arg" == "-h" ]] ; then usage_; exit 0
    elif [[ "$arg" == -* ]]; then echo "$name: unrecognised option: $arg" >&2; exit 1
    else echo "$name: unexpected argument: $arg" >&2; exit 1
    fi
done

expected_files=$( find . -name "expected" )
expected_files_count=$( find . -name "expected" | wc -l )
job_id_list=()

if (( $expected_files_count > 0 )) ; then
    batch_id=$( $sql_command "CALL getNextBatchId()" | tail -1 )
    if [[ -z "$batch_id" ]]; then echo "$name: error getting batch id; aborting"; exit 1; fi
    echo "$expected_files_count test[s] in subdirectories of $( pwd )"
    for e in $expected_files ; do
        basedir=$( pwd )
        cd $( dirname $e )
        if [[ ! -f "input" ]]; then
            echo "Warning: found \"expected\" but no \"input\" file in $( pwd )"
        else
            insert_statement=$( create_insert_statement "input" "$( pwd )" $batch_id ${#job_id_list[@]} )
            if [[ $? == 0 ]]; then
                sql_to_execute="$insert_statement; SELECT LAST_INSERT_ID();"
                job_id=$( $sql_command "$sql_to_execute" | tail -1 )
                if [[ -z "$job_id" || "$job_id" == 0 ]]; then
                    echo "$name: error executing SQL: $sql_to_execute; SELECT LAST_INSERT_ID();"
                else
                    job_id_list+=( $job_id )
                    echo "Job $job_id: $( pwd )/input"
                fi
            fi
        fi
        cd $basedir
    done
    echo "${#job_id_list[@]} job(s) submitted"
    if [[ ${#job_id_list[@]} != 0 ]]; then echo "Batch id $batch_id"; fi
else
    echo "$name: no \"expected\" files found in subdirectories of $( pwd )"
fi

